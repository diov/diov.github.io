<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[README.MD]]></title>
  <subtitle><![CDATA[Live fast. Die young. Be wild And Have fun.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://diov.github.io/"/>
  <updated>2016-01-27T05:54:52.721Z</updated>
  <id>http://diov.github.io/</id>
  
  <author>
    <name><![CDATA[Dio_V]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android 触摸事件分发源码]]></title>
    <link href="http://diov.github.io/2016/01/17/Android-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81/"/>
    <id>http://diov.github.io/2016/01/17/Android-触摸事件分发源码/</id>
    <published>2016-01-17T11:41:49.000Z</published>
    <updated>2016-01-27T05:54:52.721Z</updated>
    <content type="html"><![CDATA[<h2 id="ViewGroup_u4E8B_u4EF6_u7684_u5206_u53D1_u62E6_u622A_u548C_u5904_u7406"><a href="#ViewGroup_u4E8B_u4EF6_u7684_u5206_u53D1_u62E6_u622A_u548C_u5904_u7406" class="headerlink" title="ViewGroup事件的分发拦截和处理"></a>ViewGroup事件的分发拦截和处理</h2><p>触摸事件一般是从Activity开始分发，但是这里我们就跳过Activity，直接从根布局也就是ViewGroup开始了。</p>
<h3 id="u4E8B_u4EF6_u5206_u53D1_28dispatchTouchEvent_29"><a href="#u4E8B_u4EF6_u5206_u53D1_28dispatchTouchEvent_29" class="headerlink" title="事件分发(dispatchTouchEvent)"></a>事件分发(dispatchTouchEvent)</h3><ul>
<li><h4 id="u6E90_u7801"><a href="#u6E90_u7801" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*...省略...*/</span></span><br><span class="line">        <span class="comment">// 1. 将ACTION_DOWN事件作为一系列触摸事件的起始，对事件进行初始化.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 在开始一系列新的手势时清除之前的所有状态（可能由于app切换、ANR所遗留下来）</span></span><br><span class="line">            <span class="comment">// 将mFirstTouchTarget重置为null(在clearTouchTargets()中)，并且回收事件</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();<span class="comment">// 重置所有的触摸状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 检测是否需要拦截.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当触摸事件为ACTION_DOWN或者mFirstTouchTarget不为null时（也就是已经找到接受事件并可以接受后续事件的子View）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)可以设置ViewGroup是否禁用拦截</span></span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                <span class="comment">// 如果没有禁用拦截，那么就调用当前ViewGroup的onInterceptTouchEvent()方法。对是否拦截进行判断</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果禁用拦截，那么直接返回false</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 触摸事件不是初始的ACTION_DOWN事件，并且没有接收后续事件的View控件。ViewGroup会继续拦截触摸事件</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果对事件进行了拦截，或者已经有一个控件对手势进行处理。那么进行normal的事件分发（这里不太明白）</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">// 判断事件是否是ACTION_CANCEL或者之前的手势遗留的</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;<span class="comment">// 判断VIewGroup是否可以分发事件</span></span><br><span class="line"></span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// 如果事件不是ACTION_CANCEL并且没有进行拦截</span></span><br><span class="line"></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus(): <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 3. 当事件为ACTION_DOWN时进入该方法（另两个条件不太明白）</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent</span><br><span class="line">                    .ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取触摸的位置</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                    <span class="comment">// 按照从前到后的顺序遍历子View，找到可以接收事件的子View</span></span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="comment">// 后添加的View覆盖在最上层，从集合的最后向前遍历</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>) ? children[childIndex] : preorderedList.get</span><br><span class="line">                                (childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*...省略...*/</span></span><br><span class="line">                        <span class="comment">// 如果子View不能接收事件，或者Transformed(不太明白)后的触摸点不在子View中，continue。加速查找</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child,</span><br><span class="line">                                <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果没有可以接收事件的子View就返回null，否则返回子View</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果已经找到了接收事件的子View，就跳出循环</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 通过dispatchTransformedTouchEvent()方法，递归遍历所有子View。</span></span><br><span class="line">                        <span class="comment">// 如果返回true，说明事件被子View消费了</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">//将接收并消费ACTION_DOWN事件的子View其赋值给newTouchTarget，作为后续事件的接受者。跳出循环</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有找到可以接收事件的子View，但是之前某个子View消费过触摸事件。那么将该子View赋值给newTouchTarget</span></span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 如果触摸事件不是ACTION_DOWN时，处理事件.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// a. 没有哪个子View能够消费ACTION_DOWN事件，或者后续的事件被拦截了</span></span><br><span class="line">            <span class="comment">// 将ViewGroup作为一般的View，调用dispatchTransformedTouchEvent()对事件进行处理(参数传入null)</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b. 存在某个子View能够消费ACTION_DOWN事件</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    <span class="comment">// 如果能消费ACTION_DOWN的子View，同时也在这次触摸事件中消费ACTION_DOWN事件，也就是第一次消费事件。(瞎猜的:P)</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;中</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对于ACTION_DOWN后续的事件，根据onInterceptTouchEvent()的返回值决定是否想子View发送ACTION_CANCEL</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child) || intercepted;</span><br><span class="line">                    <span class="comment">// 再将事件通过dispatchTransformedTouchEvent()交由子View处理</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*...省略...*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            <span class="comment">// 如果对后续的事件设置了CANCEL或者事件是ACTION_UP.重置事件状态</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<ol>
<li>将ACTION_DOWN事件作为一系列触摸事件的起始，对事件进行初始化.<br>这个步骤最重要的一点就是<strong>将mFirstTouchTarget置为null</strong></li>
<li>检测是否需要拦截<br>先判断当前ViewGroup是否禁用了拦截。如果禁用了，直接返回false<br>如果没有禁用，当触摸事件为ACTION_DOWN或着是接收后续事件时会调用<strong>onInterceptTouchEvent()</strong>进行判断</li>
<li>如果不进行拦截，当触摸事件为ACTION_DOWN时(触摸事件的起始)进行特殊的判断<br>递归遍历子View，找到能够消费事件的子View。在这个过程中多次调用dispatchTransformedTouchEvent()方法以递归的形式将事件依次发送给子View<br>这个步骤最重要的一点就是是否<strong>给mFirstTouchTarget赋值</strong></li>
<li>处理完ACTION_DOWN后，对事件是否消费做判断(根据<strong>mFirstTouchTarget是否为null</strong>)<br>如果没有子View可以消费事件或者事件被拦截，事件通过dispatchTransformedTouchEvent()由父ViewGroup处理，返回结果<br>如果当前事件为ACTION_DOWN并且被消费，返回true<br>如果当前事件为ACTION_DOWN的后续事件，根据onInterceptTouchEvent()的返回值决定向下分发的时ACTION_CANCEL还是当前事件。通过dispatchTransformedTouchEvent()由子View处理，返回结果</li>
</ol>
</blockquote>
<hr>
<h3 id="ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u62E6_u622A"><a href="#ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u62E6_u622A" class="headerlink" title="ViewGroup中事件的拦截"></a>ViewGroup中事件的拦截</h3><ul>
<li><h4 id="u6E90_u7801-1"><a href="#u6E90_u7801-1" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-1"><a href="#u6E90_u7801_u5206_u6790-1" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>ViewGroup中对事件是不进行拦截的，将其向下传送</p>
</blockquote>
<hr>
<h3 id="ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u5904_u7406"><a href="#ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u5904_u7406" class="headerlink" title="ViewGroup中事件的处理"></a>ViewGroup中事件的处理</h3><ul>
<li><h4 id="u6E90_u7801-2"><a href="#u6E90_u7801-2" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span><br><span class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">// 1. 根据传入的参数cancel或者事件决定发送的事件是否时ACTION_CANCEL</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="comment">// 2. 根据传入的参数child决定是将事件交由父ViewGroup还是交由子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; dcancelesiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-2"><a href="#u6E90_u7801_u5206_u6790-2" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>虽然这个方法很长，但是其实我们只需要关注两个参数：<code>boolean cancel</code>和<code>View child</code></p>
<ol>
<li>boolean cancel控制了发送的事件是否是ACTION_CANCEL</li>
<li>View child控制了事件是发送给子View还是交由父ViewGroup处理</li>
</ol>
<p>事件是否被消费决定了最后的返回值。</p>
</blockquote>
<ul>
<li>ViewGroup是View的子类，他并没有重写View的onTouchEvent()方法。所以如果事件交由父ViewGroup处理，实际调用的是<code>super.dispatchTouchEvent()</code></li>
</ul>
<hr>
<p>将触摸事件从ACTION_DOWN -&gt; ACTION_MOVE -&gt; ACTION_UP看做一系列触摸事件的整体。当ViewGroup处理这一系列事件的过程中，我们需要特别注意一个变量：mFirstTouchTarget。<br>在ACTION_DOWN事件中mFirstTouchTarget被置为了null。那么mFirstTouchTarget的最终值就意味着是否找到了能够消费触摸事件的子View。来看一下mFirstTouchTarget在那些情况下可以被赋值：</p>
<ol>
<li>在ACTION_DOWN事件中：a).父ViewGroup不对事件进行拦截；2).点击点位于某个子View上；3). 被点击的子View消费了ACTION_DOWN事件</li>
<li>在ACTION_DOWN的后续事件中：a). 首先必须存在可以消费ACTION_DOWN事件的子View，否则后续事件都无法向下分发；b). 在分发后续事件时，父ViewGroup不对事件进行拦截</li>
</ol>
<hr>
<h2 id="View_u4E2D_u4E8B_u4EF6_u7684_u5206_u53D1_u548C_u5904_u7406"><a href="#View_u4E2D_u4E8B_u4EF6_u7684_u5206_u53D1_u548C_u5904_u7406" class="headerlink" title="View中事件的分发和处理"></a>View中事件的分发和处理</h2><p>上面我们说到了当ViewGroup中所有的子View都无法消费触摸事件时，会把事件返回给ViewGroup，再调用View的<code>dispatchTouchEvent()</code>方法，那么就来看看具体的实现吧</p>
<h3 id="u4E8B_u4EF6_u5206_u53D1"><a href="#u4E8B_u4EF6_u5206_u53D1" class="headerlink" title="事件分发"></a>事件分发</h3><ul>
<li><h4 id="u6E90_u7801-3"><a href="#u6E90_u7801-3" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// NestedScroll是Lolipop之后添加的嵌套滚动机制，用于解决子View不处理滑动事件时，父View也无法处理的该事件的问题</span></span><br><span class="line">        <span class="comment">// 这里我们只要看作是触摸事件时清除掉之前的触摸事件的状态就可以了</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">// ListenerInfo是封装了一系列监听器的类</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            <span class="comment">// 1. 首先判断是否给View添加了onTouchListener监听器；mViewFlags是在View构造时传入的一系列状态值，这里用来判断View是否是enabled的。</span></span><br><span class="line">            <span class="comment">// 如果前面都为true，最后执行监听器的onTouch()方法，并根据其返回值决定result的值</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="comment">// 2. 当未设置onTouchListener或者onTouch()方法返回false（表示事件未被消费），则会调用onTouchEvent()方法并决定result的值</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-3"><a href="#u6E90_u7801_u5206_u6790-3" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>相比起ViewGroup，View的dispatchTouchEvent()方法就简单多了。重点主要有两点：</p>
<ol>
<li>判断View是否设置了onTouchListener，相信设置监听器的方法大家应该都知道了——setOnTouchListener()。如果设置了监听器，就调用监听器的<code>onTouch()</code>方法</li>
<li>如果没有设置监听器或者onTouch()返回false时，会调用<code>onTouchEvent()</code>方法</li>
</ol>
</blockquote>
<hr>
<h3 id="u4E8B_u4EF6_u5904_u7406"><a href="#u4E8B_u4EF6_u5904_u7406" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li><h4 id="u6E90_u7801-4"><a href="#u6E90_u7801-4" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取点击的位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当触摸事件为ACTION_UP并且View未设定pressed属性时，设置pressed状态未false</span></span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 如果当前View同时具有clickable和disabled两个属性，返回true(消费事件但不作出响应)</span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将事件委托给一个代理进行处理，如果代理的onTouchEvent()返回true，表示事件被消费（不懂）</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                    <span class="comment">//做了一系列判断，设置按下状态并迅速弹起</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// 判断未tap（轻触）状态，移除长按的回调</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果View没有夺取焦点</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// 调用一个处理Click事件的Runnable对象进行异步的处理</span></span><br><span class="line">                            <span class="comment">// 最终调用了onClickListener的onClick()方法</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="comment">// 处理长按事件等</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="comment">//移除回调、清除状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 只要View是clickable、longclickable或者contextclickable的，不论触摸事件是什么都消费事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PerformClick类中执行的还是performClick()方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformClick</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        performClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理Click事件的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        <span class="comment">// 调用onClickListener的onClick()方法</span></span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-4"><a href="#u6E90_u7801_u5206_u6790-4" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>对onTouchEvent()的分析，我们主要关注其返回值</p>
<ol>
<li>View同时具有clickable和disabled两个属性，返回true(消费事件但不作出响应)</li>
<li>只要View是clickable、longclickable或者contextclickable的，不论触摸事件是什么都消费事件</li>
<li>如果不是上面的情况，返回false</li>
</ol>
<p>要注意的是，在第二种情况下，当触摸事件是ACTION_DOWN时，创建了一个处理Click事件的Runnable对象并将其加入消息队列<br>这个Runnable对象内部执行的是performClick()方法。而我们可以看到，如果Runnable对象添加到消息队列失败的话时会直接调用这个方法的<br>在performClick()中，判断了是否设置了onClickListener，最终调用了onClickListener的onClick()方法</p>
</blockquote>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[对于View中触摸事件分发的源码分析]]>
    
    </summary>
    
      <category term="Android" scheme="http://diov.github.io/tags/Android/"/>
    
      <category term="code" scheme="http://diov.github.io/categories/code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git基础命令]]></title>
    <link href="http://diov.github.io/2016/01/10/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://diov.github.io/2016/01/10/Git基础命令/</id>
    <published>2016-01-09T16:48:34.000Z</published>
    <updated>2016-01-26T12:07:19.952Z</updated>
    <content type="html"><![CDATA[<h1 id="Git_Try__u7B14_u8BB0"><a href="#Git_Try__u7B14_u8BB0" class="headerlink" title="Git Try 笔记"></a>Git Try 笔记</h1><p>Code School上<a href="https://try.github.io/" target="_blank" rel="external">Git Try</a>的学习笔记。</p>
<p>之前直接在Android Studio上使用git插件的时候，因为不了解git的命令和运作，搞出了不少岔子。最惨的时直接删了两个repository…</p>
<p>用上Linux Mint后慢慢的对Command Line熟悉起来，想着把git再好好研究一下。本文的名称大多沿用<a href="http://www.ruanyifeng.com/blog" target="_blank" rel="external">阮一峰博客</a>的命名</p>
<hr>
<ul>
<li>初始化一个<code>Git</code>代码库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init&#10;&#10;Initialized empty Git repository in /.git/&#10;&#10;Success!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仓库(Repository)就是Git初始化后，用来进行版本控制的文件夹</p>
</blockquote>
<hr>
<ul>
<li>获取本地<code>Git</code>代码库的状态</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git statu&#10;&#10;# On branch master&#10;#&#10;# Initial commit&#10;#&#10;nothing to commit (create/copy files and use &#34;git add&#34; to track)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显示Git分支、提交的内容</p>
<p>当仓库中的文件发生改变时，通常会有以下状态</p>
<ol>
<li>untracked：尚未被Git检索的状态</li>
<li>staged：准备被Git提交(<code>commit</code>)，可以理解为暂存在本地仓库</li>
<li>unstaged：不会被Git提交</li>
<li>deleted：文件在本地被删除，等待在Git上删除</li>
</ol>
<hr>
</blockquote>
<ul>
<li>将文件添加到本地<code>Git</code>缓存区中</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add xxx.txt&#10;$ git add &#8216;*.txt&#8217;&#10;$ git add -A&#10;&#10;Nice job, you&#39;ve added xxx.txt to the Staging Area</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过add命令将文件保存到临时区域()。支持通配符及全部上传</p>
<p>Staging Area:缓存区，在我们通过<code>commit</code>将文件提交到<code>Git</code>上之前临时保存</p>
</blockquote>
<hr>
<ul>
<li>将缓存区的文件提交到<code>Git</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#8216;xxx&#8217;&#10;&#10;[master (root-commit) 2e8cda3] Add cute octocat&#10; 1 file changed, 1 insertion(+)&#10; create mode 100644 octocat.txt&#10;&#10;Success!</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>commit</code>:是仓库状态的一个存档，通过<code>commit</code>可以查看提交的所有log<br><code>-m ‘xxx&#39;</code>：每次提交的备注</p>
</blockquote>
<hr>
<ul>
<li>查看提交记录</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log&#10;$ git log --summary</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过<code>--summary</code>查看详细的记录(包括提交作者、时间、备注及每个更改的文件信息)</p>
</blockquote>
<hr>
<ul>
<li>增加一个远程<code>Git</code>仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/try-git/try_git.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个远程仓库，地址为github上提供的地址。并且将该远程仓库命名为origin</p>
</blockquote>
<hr>
<ul>
<li>将本地仓库推送到远程仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>origin是远程仓库的命名，分支默认是master<br><code>-u</code>表示Git会记住Git状态，下次只需要通过<code>git push</code>就可以进行推送</p>
</blockquote>
<hr>
<ul>
<li>从远程<code>Git</code>仓库同步</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将远程仓库同步代码，与本地合并<br><code>git stash</code>：当同步文件时，可能不想将本地的更改覆盖。可以通过stash命令将本地的更改隐藏<br>在同步完成后，再调用<code>git stash apply</code>将本地更改应用到仓库</p>
</blockquote>
<hr>
<ul>
<li>比较缓存区与仓库的代码差异</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HEAD：HEAD是记录不同<code>commit</code>位置的标示，默认的HEAD是最近一次提交的<code>commit</code><br>所以通过HEAD可以快速地确定所在版本，而不需要对比SHA值<br>通过<code>diff</code>命令，可以显示文件之间的冲突</p>
</blockquote>
<hr>
<ul>
<li>重置缓存区的文件</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset xxx.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将缓存区的文件重置到上一次<code>commit</code></p>
</blockquote>
<hr>
<ul>
<li>将缓存区的文件恢复到工作区</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- xxx.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>reset</code>命令重置后，缓存区的文件仍然存在。通过<code>checkout</code>命令将其恢复到工作区</p>
</blockquote>
<hr>
<ul>
<li>创建本地分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>branch</code>命令可以在版本控制中创建一个分支。<br>分支是并发开发的基础，在分支上开发后可以再合并到主分支上。</p>
</blockquote>
<hr>
<ul>
<li>查看分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch&#10;&#10; clean_up&#27;&#10;* &#27;master&#27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>branch</code>命令可以查看本地的分支及当前所在的分支</p>
</blockquote>
<hr>
<ul>
<li>切换分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &#60;branch&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 可以通过git checkout -b <branch>命令同时实现创建+切换分支的操作</branch></p>
</blockquote>
<hr>
<ul>
<li>清空所有仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &#39;*.txt&#39;&#10;$ git rm -r &#60;fold_name&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的命令与Linux命令行相同，支持通配符和递归删除文件夹<br>如果没有通过命令行，直接删除文件的话，还是需要把删除的文件通过<code>git rm</code>命令在<code>Git</code>中删除的。<br>可以在<code>git commit</code>命令中使用<code>-a</code>来自动移除已被删除的文件。例如：`git commit -am <message>‘</message></p>
</blockquote>
<hr>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master&#10;$ git merge clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并分支首选需要切换会朱分支，再通过<code>merge</code>命令合并分支</p>
</blockquote>
<hr>
<ul>
<li>删除分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>branch</code>命令后加入<code>-d</code>表明删除(delete)<br>如果尚未合并，<code>-d</code>命令不会起作用。可以添加<code>-d-f</code>强制删除(force)，或者<code>-D</code></p>
</blockquote>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[Code School上Git Try的学习笔记]]>
    
    </summary>
    
      <category term="Git" scheme="http://diov.github.io/tags/Git/"/>
    
      <category term="CVS" scheme="http://diov.github.io/categories/CVS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hello]]></title>
    <link href="http://diov.github.io/2016/01/01/hello/"/>
    <id>http://diov.github.io/2016/01/01/hello/</id>
    <published>2016-01-01T11:28:07.000Z</published>
    <updated>2016-01-26T07:56:23.290Z</updated>
    <content type="html"><![CDATA[<p>Hello Github!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hello Github!</p>
]]>
    </summary>
    
  </entry>
  
</feed>
