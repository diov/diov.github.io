<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[正确地使用引导画面]]></title>
      <url>http://diov.github.io/2016/02/12/%5B%E8%AF%91%5D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>原文：<a href="https://www.bignerdranch.com/blog/splash-screens-the-right-way/(" target="_blank" rel="external">Splash Screens the Right Way – bignerdranch.com</a></p>
<hr>
<p>启动界面只是用来浪费时间的，对吧？作为一个Android开发人员，当我看到一个引导界面时，我就知道有些可怜的码农又得在代码中添加一个3秒的延迟消息了。然后，在使用这个应用之前，我就只能跟个傻逼一样盯着画面3秒钟。而每次启动应用的时候，都必须经受这种折磨！</p>
<h1 id="What_Google_Recommends"><a href="#What_Google_Recommends" class="headerlink" title="What Google Recommends"></a>What Google Recommends</h1><p>当发现Google在<a href="https://www.google.com/design/spec/patterns/launch-screens.html" target="_blank" rel="external">material design规范</a>中建议你使用引导界面时，你可能会感到有些惊讶。<br>因为在此之前，Google曾经建议开发者不要使用引导界面，甚至称其为<a href="https://youtu.be/pEGWcMTxs3I?t=1434" target="_blank" rel="external">anti-pattern</a>。<br><img src="https://www.bignerdranch.com/img/blog/2015/08/adia_no_splash.png" alt="Anti-pattern"><br>那么这中间究竟发生了什么呢？</p>
<h1 id="Splash_Screens_the_Right_Way"><a href="#Splash_Screens_the_Right_Way" class="headerlink" title="Splash Screens the Right Way"></a>Splash Screens the Right Way</h1><p>我相信Google并没有打自己的脸，之前的建议与最新的建议并不矛盾。（但是仅仅为了添加引导界面而去浪费用户的时间并不是一个好主意。请不要这么做！）<br>一个Android应用在启动的时候总会花上一点时间，尤其是在冷启动（code start）时，通常这段时间总是无可避免的。那么，与其留下一个空白的屏幕，何不给用户展示一些有趣的东西呢？这应该就是Google建议的方式吧：当用户第一次启动应用的时候，不要浪费他们的时间，当然也不要展示一个空白的页面。<br>你可以在Google app最近的几次更新中观察到他们是如何正确地使用引导界面的，比如YouTube客户端：<br><img src="https://www.bignerdranch.com/img/blog/2015/08/youtube_splash.gif" alt="YouTube app"><br>当应用冷启动时（通常意味着这是启动应用最慢的情况），他展示引导界面的时间正好就是应用做一些初始化配置的时间。而如果一个应用已经被缓存了（后台进程），引导界面可能只会一闪而过。  </p>
<h1 id="Implementing_a_Splash_Screen"><a href="#Implementing_a_Splash_Screen" class="headerlink" title="Implementing a Splash Screen"></a>Implementing a Splash Screen</h1><p>如果我们使用布局文件给Activity添加内容，就需要消耗将布局文件转换为View的时间。所以我们需要将Activity的主题中的背景作为引导界面的内容来展示。首先在 <code>res/dralable</code> 中创建一个XML文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">layer-list</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">        <span class="attribute">android:drawable</span>=<span class="value">"@color/gray"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bitmap</span></span><br><span class="line">            <span class="attribute">android:gravity</span>=<span class="value">"center"</span></span><br><span class="line">            <span class="attribute">android:src</span>=<span class="value">"@mipmap/ic_launcher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在XML文件中，定义了背景颜色以及一个位图。<br>之后，需要将这些布局设置为引导界面的主题中的背景。在<code>styles.xml</code>中为引导界面添加主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"SplashTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.NoActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">android</span><span class="pseudo">:windowBackground"</span>&gt;<span class="at_rule">@<span class="keyword">drawable/background_splash&lt;/item&gt;</span></span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>SplashTheme</code>中，将drawable中的XML文件设置为页面背景的属性。再在<code>AndroidManifest.xml</code>中为Activity添加主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".SplashActivity"</span></span><br><span class="line">    <span class="attribute">android:theme</span>=<span class="value">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，在<code>SplashActvity</code>中，应该添加跳转到主界面的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：引导界面的内容是由主题中的属性决定的，而不是将View添加到引导界面中的。<br>如果你为给Activity准备了一个布局文件，那么Activity中的内容只会在应用初始化完成之后才可见，那时候通常都太迟了。我们要做的是应用初始化之前，在尽可能短的时间内将引导界面的内容展示出来。</p>
<h1 id="Doing_it_Right"><a href="#Doing_it_Right" class="headerlink" title="Doing it Right"></a>Doing it Right</h1><p>经过上面的步骤，我们就实现了一个引导界面：<br><img src="https://www.bignerdranch.com/img/blog/2015/08/sample_splash.gif" alt="right way splash view">  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[KillPay开发（AccessibleService）]]></title>
      <url>http://diov.github.io/2016/01/28/KillPay%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>之前用<a href="http://coolapk.com/apk/com.oasisfeng.greenify" target="_blank" rel="external">绿色守护</a>的时候有一个功能，强制关闭后台进程。如果没有root的话，其实就时调用应用的详情页，然后强制停止。<br>刷完机以后并不打算安装支付宝（愈来愈流氓了），没几天就发现已经少不了这玩意儿了..</p>
<p>正好这段时间，有好多人自己开发抢红包的小应用，用到的就是AccessibleService。正好可以用来实现我的功能需求。先来分析一下业务，其实非常的简单：</p>
<ol>
<li>将AccessibleService开启</li>
<li>如果后台有进程在运行，跳转到应用详情界面</li>
<li>通过AccessibleService将进程停止</li>
</ol>
<p>用到的都是SDK中提供的API，如果有不明白的可以查阅文档，很详细。</p>
<h1 id="u754C_u9762_u8DF3_u8F6C"><a href="#u754C_u9762_u8DF3_u8F6C" class="headerlink" title="界面跳转"></a>界面跳转</h1><p>整个应用涉及到两个跳转，一个是”无障碍”（或者叫“辅助”）界面的跳转，另一个是指定应用的应用详情界面的跳转。<br>先来实现跳转无障碍界面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent accessibleIntent = <span class="keyword">new</span> Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);</span><br><span class="line">startActivity(accessibleIntent);</span><br></pre></td></tr></table></figure></p>
<p>接着是跳转到应用详情界面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent i = <span class="keyword">new</span> Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">i.setData(Uri.parse(<span class="string">"package:"</span> + packageName));</span><br><span class="line">startActivity(i);</span><br></pre></td></tr></table></figure></p>
<p>这里需要通过<code>setData(Uri data)</code>方法传入一个Uri，确定跳转到那个应用的详情界面。</p>
<h1 id="u81EA_u52A8_u5173_u95ED"><a href="#u81EA_u52A8_u5173_u95ED" class="headerlink" title="自动关闭"></a>自动关闭</h1><p>跳转到详情界面以后就是实现功能的关键步骤，通过AccessibleService自动关闭后台进程。首先来看一下AccessibleService的官方描述：</p>
<blockquote>
<p>An accessibility service is an application that provides user interface enhancements to assist users with disabilities, or who may temporarily be unable to fully interact with a device. For example, users who are driving, taking care of a young child or attending a very loud party might need additional or alternative interface feedback.</p>
</blockquote>
<p>也就是说AccessibleService是为不方便使用手机的人准备的，那我们正好不方便去点击”强制停止”-&gt;“确认”按钮（懒），所以完全可以借助这个API来实现自动的点击。</p>
<p>下面正式来使用AccessibleService：</p>
<ol>
<li><p><strong>在清单文件中注册</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".util.ForcecloseAccessibilityService"</span></span><br><span class="line">    <span class="attribute">android:label</span>=<span class="value">"@string/accessibility_service_label"</span></span><br><span class="line">    <span class="attribute">android:permission</span>=<span class="value">"android.permission.BIND_ACCESSIBILITY_SERVICE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.accessibilityservice.AccessibilityService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"android.accessibilityservice"</span></span><br><span class="line">        <span class="attribute">android:resource</span>=<span class="value">"@xml/accessibility_service_config"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想要使用AccessibleService必须要获取到<code>android.permission.BIND_ACCESSIBILITY_SERVICE</code>这个权限，<code>intent-filter</code>中的内容按照官方文档来填写就行了。至于<code>name</code>和<code>label</code>标签就不解释了。而<code>meta-data</code>中配置了服务的一些属性，我们在下一步完成</p>
</li>
<li><p><strong>配置AccessibleService</strong></p>
<p>在xml文件夹下创建一个.xml文件，文件名与<code>meta-data</code>中的<code>resource</code>保持一致就可以了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">accessibility-service</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:accessibilityEventTypes</span>=<span class="value">"typeAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFeedbackType</span>=<span class="value">"feedbackAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFlags</span>=<span class="value">"flagDefault"</span></span><br><span class="line">    <span class="attribute">android:canRetrieveWindowContent</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:description</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:notificationTimeout</span>=<span class="value">"100"</span></span><br><span class="line">    <span class="attribute">android:packageNames</span>=<span class="value">"com.android.settings"</span></span><br><span class="line">    /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>android:accessibilityEventTypes</code>：接受事件的类型</li>
<li><code>android:accessibilityFeedbackType</code>：对事件反馈的类型</li>
<li><code>android:canRetrieveWindowContent</code>：服务能否获取页面内容</li>
<li><code>android:packageNames</code>：想要监听那个包下的内容。注意，当我们使用AccessibleService来获取页面上的内容时，他是遍历所有的控件。如果不这是指定的报名的话，开启服务后会消耗大量的资源，所以建议如果只需要监听特定界面的话直接指定包名。</li>
</ul>
</li>
<li><p><strong>创建AccessibleService的子类</strong></p>
<p>创建AccessibleService的子类，需要实现<code>onAccessibilityEvent(AccessibilityEvent event)</code>和<code>`onInterrupt()</code>方法。其中我们对于自动关闭的业务逻辑就写在<code>onAccessibilityEvent(AccessibilityEvent event)</code>方法中，当服务接收到AccessibilityEvent时会回调这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndPerformAction</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找当前窗口中包含文字的按钮</span></span><br><span class="line">    <span class="keyword">if</span> (getRootInActiveWindow() == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//通过文字找到当前的节点</span></span><br><span class="line">    List&lt;AccessibilityNodeInfo&gt; nodes = getRootInActiveWindow().findAccessibilityNodeInfosByText(text);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">        AccessibilityNodeInfo node = nodes.get(i);</span><br><span class="line">        <span class="comment">// 执行按钮点击行为</span></span><br><span class="line">        <span class="keyword">if</span> (node.getClassName().equals(<span class="string">"android.widget.Button"</span>) &amp;&amp; node.isEnabled()) &#123;</span><br><span class="line">            node.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自定义的AccessibleService中，主要的方法就是自定义的<code>findAndPerformAction()</code>方法。<br>窗口内所有的控件及相关的内容都被封装在了<code>AccessibilityNodeInfo</code>对象中，根布局的<code>AccessibilityNodeInfo</code>下每一个控件仍然是一个个<code>AccessibilityNodeInfo</code>对象（与<code>jsonObject</code>的结构相似）。</p>
<ul>
<li>首先是通过<code>getRootInActiveWindow()</code>获取根布局，该方法在API 16才添加。API 16之前的可以使用<code>getResources()</code>方法；</li>
<li>之后调用<code>findAccessibilityNodeInfoByText(String text)</code>方法遍历所有的子控件，根据指定的字符串找到控件的集合；</li>
<li>因为我们已经知道在应用详情的界面，通常一个指定的字符串只会出现在一个控件上。所以直接获取集合的第一个元素，调用<code>performAction(int action)</code>，传入<code>AccessibilityNodeInfo.ACTION_CLICK</code>，完成点击事件。</li>
</ul>
<p>之后，在<code>onAccessibilityEvent(AccessibilityEvent event)</code>方法中，我们只需要依次调用<code>findAndPerformAction(&quot;强行停止&quot;)</code>和<code>findAndPerformAction(&quot;确定&quot;)</code>就可以实现自动停止进程的功能了。</p>
</li>
</ol>
<h1 id="u4E00_u4E9B_u91CD_u6784"><a href="#u4E00_u4E9B_u91CD_u6784" class="headerlink" title="一些重构"></a>一些重构</h1><p>写完之后发现在<code>MainActivity.java</code>中加入了不少 <em>迷之嵌套</em> ，就简单的重构了一下。<br>其实在实际开发中对于业务逻辑不注意的话很容易就添加很多嵌套，增大了代码阅读的难度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isInstall) &#123;</span><br><span class="line">    Snackbar.make(view, <span class="string">"应用未安装"</span>, Snackbar.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">    Snackbar.make(view, <span class="string">"后台未运行,无需关闭"</span>, Snackbar.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (AppHelper.isServiceRunning(MainActivity.<span class="keyword">this</span>, getPackageName())) &#123;</span><br><span class="line">    <span class="comment">// 根据包名跳转系统自带的应用程序信息界面,并自动关闭</span></span><br><span class="line">    jumpDetailInfo(packageName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Snackbar.make(view, <span class="string">"服务未开启,请打开"</span>, Snackbar.LENGTH_SHORT).setAction(<span class="string">"打开"</span>,</span><br><span class="line">            <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    openAccessibleSetting();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是重构后的代码，感觉仍然写的不够优雅…</p>
<p>至此，这个应用的主要功能就都完成了。因为都是直接调用SDK中的API，所以并没有什么难点。其他的一些查询应用安装及后台是否运行的方法也很简单，就不一一介绍了。有兴趣的可以查看我的仓库 <a href="https://github.com/diov/KillAPay" target="_blank" rel="external">diov/KillAPay</a></p>
<h3 id="u4E00_u4E9B_u9898_u5916_u8BDD"><a href="#u4E00_u4E9B_u9898_u5916_u8BDD" class="headerlink" title="一些题外话"></a>一些题外话</h3><p>十月份时候百度全家桶爆出的漏洞（后台），和最近了解到的支付宝各种强制开启“生活圈”和后台下载小视频，以及支付宝iOS端的后台播放无声音乐（多老的招数了）。似乎BAT里面反倒是山寨帝国Tencent显得最良心了。<br>不可否认BAT在国内互联网行业中的技术领军地位，也很佩服淘宝这样的应用要应对500多个业务还能很好实现（虽然很丑陋）的强大。但是真的想不明白这样完全不在乎用户感受的设计是出于什么样的一种考虑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 触摸事件分发源码]]></title>
      <url>http://diov.github.io/2016/01/17/Android-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://trinea.github.io/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf" target="_blank" rel="external">Mastering    the    Android Touch    System</a></p>
<h2 id="ViewGroup_u4E8B_u4EF6_u7684_u5206_u53D1_u62E6_u622A_u548C_u5904_u7406"><a href="#ViewGroup_u4E8B_u4EF6_u7684_u5206_u53D1_u62E6_u622A_u548C_u5904_u7406" class="headerlink" title="ViewGroup事件的分发拦截和处理"></a>ViewGroup事件的分发拦截和处理</h2><p>触摸事件一般是从Activity开始分发，但是这里我们就跳过Activity，直接从根布局也就是ViewGroup开始了。</p>
<h3 id="u4E8B_u4EF6_u5206_u53D1_28dispatchTouchEvent_29"><a href="#u4E8B_u4EF6_u5206_u53D1_28dispatchTouchEvent_29" class="headerlink" title="事件分发(dispatchTouchEvent)"></a>事件分发(dispatchTouchEvent)</h3><ul>
<li><h4 id="u6E90_u7801"><a href="#u6E90_u7801" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*...省略...*/</span></span><br><span class="line">        <span class="comment">// 1. 将ACTION_DOWN事件作为一系列触摸事件的起始，对事件进行初始化.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 在开始一系列新的手势时清除之前的所有状态（可能由于app切换、ANR所遗留下来）</span></span><br><span class="line">            <span class="comment">// 将mFirstTouchTarget重置为null(在clearTouchTargets()中)，并且回收事件</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();<span class="comment">// 重置所有的触摸状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 检测是否需要拦截.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当触摸事件为ACTION_DOWN或者mFirstTouchTarget不为null时（也就是已经找到接受事件并可以接受后续事件的子View）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)可以设置ViewGroup是否禁用拦截</span></span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                <span class="comment">// 如果没有禁用拦截，那么就调用当前ViewGroup的onInterceptTouchEvent()方法。对是否拦截进行判断</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果禁用拦截，那么直接返回false</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 触摸事件不是初始的ACTION_DOWN事件，并且没有接收后续事件的View控件。ViewGroup会继续拦截触摸事件</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果对事件进行了拦截，或者已经有一个控件对手势进行处理。那么进行normal的事件分发（这里不太明白）</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">// 判断事件是否是ACTION_CANCEL或者之前的手势遗留的</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;<span class="comment">// 判断VIewGroup是否可以分发事件</span></span><br><span class="line"></span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// 如果事件不是ACTION_CANCEL并且没有进行拦截</span></span><br><span class="line"></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus(): <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 3. 当事件为ACTION_DOWN时进入该方法（另两个条件不太明白）</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent</span><br><span class="line">                    .ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取触摸的位置</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                    <span class="comment">// 按照从前到后的顺序遍历子View，找到可以接收事件的子View</span></span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="comment">// 后添加的View覆盖在最上层，从集合的最后向前遍历</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>) ? children[childIndex] : preorderedList.get</span><br><span class="line">                                (childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*...省略...*/</span></span><br><span class="line">                        <span class="comment">// 如果子View不能接收事件，或者Transformed(不太明白)后的触摸点不在子View中，continue。加速查找</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child,</span><br><span class="line">                                <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果没有可以接收事件的子View就返回null，否则返回子View</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果已经找到了接收事件的子View，就跳出循环</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 通过dispatchTransformedTouchEvent()方法，递归遍历所有子View。</span></span><br><span class="line">                        <span class="comment">// 如果返回true，说明事件被子View消费了</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">//将接收并消费ACTION_DOWN事件的子View其赋值给newTouchTarget，作为后续事件的接受者。跳出循环</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有找到可以接收事件的子View，但是之前某个子View消费过触摸事件。那么将该子View赋值给newTouchTarget</span></span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 如果触摸事件不是ACTION_DOWN时，处理事件.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// a. 没有哪个子View能够消费ACTION_DOWN事件，或者后续的事件被拦截了</span></span><br><span class="line">            <span class="comment">// 将ViewGroup作为一般的View，调用dispatchTransformedTouchEvent()对事件进行处理(参数传入null)</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b. 存在某个子View能够消费ACTION_DOWN事件</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    <span class="comment">// 如果能消费ACTION_DOWN的子View，同时也在这次触摸事件中消费ACTION_DOWN事件，也就是第一次消费事件。(瞎猜的:P)</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;中</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对于ACTION_DOWN后续的事件，根据onInterceptTouchEvent()的返回值决定是否想子View发送ACTION_CANCEL</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child) || intercepted;</span><br><span class="line">                    <span class="comment">// 再将事件通过dispatchTransformedTouchEvent()交由子View处理</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*...省略...*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            <span class="comment">// 如果对后续的事件设置了CANCEL或者事件是ACTION_UP.重置事件状态</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<ol>
<li>将ACTION_DOWN事件作为一系列触摸事件的起始，对事件进行初始化.<br>这个步骤最重要的一点就是<strong>将mFirstTouchTarget置为null</strong></li>
<li>检测是否需要拦截<br>先判断当前ViewGroup是否禁用了拦截。如果禁用了，直接返回false<br>如果没有禁用，当触摸事件为ACTION_DOWN或着是接收后续事件时会调用<strong>onInterceptTouchEvent()</strong>进行判断</li>
<li>如果不进行拦截，当触摸事件为ACTION_DOWN时(触摸事件的起始)进行特殊的判断<br>递归遍历子View，找到能够消费事件的子View。在这个过程中多次调用dispatchTransformedTouchEvent()方法以递归的形式将事件依次发送给子View<br>这个步骤最重要的一点就是是否<strong>给mFirstTouchTarget赋值</strong></li>
<li>处理完ACTION_DOWN后，对事件是否消费做判断(根据<strong>mFirstTouchTarget是否为null</strong>)<br>如果没有子View可以消费事件或者事件被拦截，事件通过dispatchTransformedTouchEvent()由父ViewGroup处理，返回结果<br>如果当前事件为ACTION_DOWN并且被消费，返回true<br>如果当前事件为ACTION_DOWN的后续事件，根据onInterceptTouchEvent()的返回值决定向下分发的时ACTION_CANCEL还是当前事件。通过dispatchTransformedTouchEvent()由子View处理，返回结果</li>
</ol>
</blockquote>
<hr>
<h3 id="ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u62E6_u622A"><a href="#ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u62E6_u622A" class="headerlink" title="ViewGroup中事件的拦截"></a>ViewGroup中事件的拦截</h3><ul>
<li><h4 id="u6E90_u7801-1"><a href="#u6E90_u7801-1" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-1"><a href="#u6E90_u7801_u5206_u6790-1" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>ViewGroup中对事件是不进行拦截的，将其向下传送</p>
</blockquote>
<hr>
<h3 id="ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u5904_u7406"><a href="#ViewGroup_u4E2D_u4E8B_u4EF6_u7684_u5904_u7406" class="headerlink" title="ViewGroup中事件的处理"></a>ViewGroup中事件的处理</h3><ul>
<li><h4 id="u6E90_u7801-2"><a href="#u6E90_u7801-2" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span><br><span class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">// 1. 根据传入的参数cancel或者事件决定发送的事件是否时ACTION_CANCEL</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="comment">// 2. 根据传入的参数child决定是将事件交由父ViewGroup还是交由子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; dcancelesiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-2"><a href="#u6E90_u7801_u5206_u6790-2" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>虽然这个方法很长，但是其实我们只需要关注两个参数：<code>boolean cancel</code>和<code>View child</code></p>
<ol>
<li>boolean cancel控制了发送的事件是否是ACTION_CANCEL</li>
<li>View child控制了事件是发送给子View还是交由父ViewGroup处理</li>
</ol>
<p>事件是否被消费决定了最后的返回值。</p>
</blockquote>
<ul>
<li>ViewGroup是View的子类，他并没有重写View的onTouchEvent()方法。所以如果事件交由父ViewGroup处理，实际调用的是<code>super.dispatchTouchEvent()</code></li>
</ul>
<hr>
<p>将触摸事件从ACTION_DOWN -&gt; ACTION_MOVE -&gt; ACTION_UP看做一系列触摸事件的整体。当ViewGroup处理这一系列事件的过程中，我们需要特别注意一个变量：mFirstTouchTarget。<br>在ACTION_DOWN事件中mFirstTouchTarget被置为了null。那么mFirstTouchTarget的最终值就意味着是否找到了能够消费触摸事件的子View。来看一下mFirstTouchTarget在那些情况下可以被赋值：</p>
<ol>
<li>在ACTION_DOWN事件中：a).父ViewGroup不对事件进行拦截；2).点击点位于某个子View上；3). 被点击的子View消费了ACTION_DOWN事件</li>
<li>在ACTION_DOWN的后续事件中：a). 首先必须存在可以消费ACTION_DOWN事件的子View，否则后续事件都无法向下分发；b). 在分发后续事件时，父ViewGroup不对事件进行拦截</li>
</ol>
<hr>
<h2 id="View_u4E2D_u4E8B_u4EF6_u7684_u5206_u53D1_u548C_u5904_u7406"><a href="#View_u4E2D_u4E8B_u4EF6_u7684_u5206_u53D1_u548C_u5904_u7406" class="headerlink" title="View中事件的分发和处理"></a>View中事件的分发和处理</h2><p>上面我们说到了当ViewGroup中所有的子View都无法消费触摸事件时，会把事件返回给ViewGroup，再调用View的<code>dispatchTouchEvent()</code>方法，那么就来看看具体的实现吧</p>
<h3 id="u4E8B_u4EF6_u5206_u53D1"><a href="#u4E8B_u4EF6_u5206_u53D1" class="headerlink" title="事件分发"></a>事件分发</h3><ul>
<li><h4 id="u6E90_u7801-3"><a href="#u6E90_u7801-3" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// NestedScroll是Lolipop之后添加的嵌套滚动机制，用于解决子View不处理滑动事件时，父View也无法处理的该事件的问题</span></span><br><span class="line">        <span class="comment">// 这里我们只要看作是触摸事件时清除掉之前的触摸事件的状态就可以了</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">// ListenerInfo是封装了一系列监听器的类</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            <span class="comment">// 1. 首先判断是否给View添加了onTouchListener监听器；mViewFlags是在View构造时传入的一系列状态值，这里用来判断View是否是enabled的。</span></span><br><span class="line">            <span class="comment">// 如果前面都为true，最后执行监听器的onTouch()方法，并根据其返回值决定result的值</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="comment">// 2. 当未设置onTouchListener或者onTouch()方法返回false（表示事件未被消费），则会调用onTouchEvent()方法并决定result的值</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-3"><a href="#u6E90_u7801_u5206_u6790-3" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>相比起ViewGroup，View的dispatchTouchEvent()方法就简单多了。重点主要有两点：</p>
<ol>
<li>判断View是否设置了onTouchListener，相信设置监听器的方法大家应该都知道了——setOnTouchListener()。如果设置了监听器，就调用监听器的<code>onTouch()</code>方法</li>
<li>如果没有设置监听器或者onTouch()返回false时，会调用<code>onTouchEvent()</code>方法</li>
</ol>
</blockquote>
<hr>
<h3 id="u4E8B_u4EF6_u5904_u7406"><a href="#u4E8B_u4EF6_u5904_u7406" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li><h4 id="u6E90_u7801-4"><a href="#u6E90_u7801-4" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取点击的位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当触摸事件为ACTION_UP并且View未设定pressed属性时，设置pressed状态未false</span></span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 如果当前View同时具有clickable和disabled两个属性，返回true(消费事件但不作出响应)</span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将事件委托给一个代理进行处理，如果代理的onTouchEvent()返回true，表示事件被消费（不懂）</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                    <span class="comment">//做了一系列判断，设置按下状态并迅速弹起</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// 判断未tap（轻触）状态，移除长按的回调</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果View没有夺取焦点</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// 调用一个处理Click事件的Runnable对象进行异步的处理</span></span><br><span class="line">                            <span class="comment">// 最终调用了onClickListener的onClick()方法</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="comment">// 处理长按事件等</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="comment">//移除回调、清除状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 只要View是clickable、longclickable或者contextclickable的，不论触摸事件是什么都消费事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PerformClick类中执行的还是performClick()方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformClick</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        performClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理Click事件的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        <span class="comment">// 调用onClickListener的onClick()方法</span></span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="u6E90_u7801_u5206_u6790-4"><a href="#u6E90_u7801_u5206_u6790-4" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>对onTouchEvent()的分析，我们主要关注其返回值</p>
<ol>
<li>View同时具有clickable和disabled两个属性，返回true(消费事件但不作出响应)</li>
<li>只要View是clickable、longclickable或者contextclickable的，不论触摸事件是什么都消费事件</li>
<li>如果不是上面的情况，返回false</li>
</ol>
<p>要注意的是，在第二种情况下，当触摸事件是ACTION_DOWN时，创建了一个处理Click事件的Runnable对象并将其加入消息队列<br>这个Runnable对象内部执行的是performClick()方法。而我们可以看到，如果Runnable对象添加到消息队列失败的话时会直接调用这个方法的<br>在performClick()中，判断了是否设置了onClickListener，最终调用了onClickListener的onClick()方法</p>
</blockquote>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git基础命令]]></title>
      <url>http://diov.github.io/2016/01/10/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="Git_Try__u7B14_u8BB0"><a href="#Git_Try__u7B14_u8BB0" class="headerlink" title="Git Try 笔记"></a>Git Try 笔记</h1><p>Code School上<a href="https://try.github.io/" target="_blank" rel="external">Git Try</a>的学习笔记。</p>
<p>之前直接在Android Studio上使用git插件的时候，因为不了解git的命令和运作，搞出了不少岔子。最惨的时直接删了两个repository…</p>
<p>用上Linux Mint后慢慢的对Command Line熟悉起来，想着把git再好好研究一下。本文的名称大多沿用<a href="http://www.ruanyifeng.com/blog" target="_blank" rel="external">阮一峰博客</a>的命名</p>
<hr>
<ul>
<li>初始化一个<code>Git</code>代码库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init&#10;&#10;Initialized empty Git repository in /.git/&#10;&#10;Success!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仓库(Repository)就是Git初始化后，用来进行版本控制的文件夹</p>
</blockquote>
<hr>
<ul>
<li>获取本地<code>Git</code>代码库的状态</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git statu&#10;&#10;# On branch master&#10;#&#10;# Initial commit&#10;#&#10;nothing to commit (create/copy files and use &#34;git add&#34; to track)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显示Git分支、提交的内容</p>
<p>当仓库中的文件发生改变时，通常会有以下状态</p>
<ol>
<li>untracked：尚未被Git检索的状态</li>
<li>staged：准备被Git提交(<code>commit</code>)，可以理解为暂存在本地仓库</li>
<li>unstaged：不会被Git提交</li>
<li>deleted：文件在本地被删除，等待在Git上删除</li>
</ol>
<hr>
</blockquote>
<ul>
<li>将文件添加到本地<code>Git</code>缓存区中</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add xxx.txt&#10;$ git add &#8216;*.txt&#8217;&#10;$ git add -A&#10;&#10;Nice job, you&#39;ve added xxx.txt to the Staging Area</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过add命令将文件保存到临时区域()。支持通配符及全部上传</p>
<p>Staging Area:缓存区，在我们通过<code>commit</code>将文件提交到<code>Git</code>上之前临时保存</p>
</blockquote>
<hr>
<ul>
<li>将缓存区的文件提交到<code>Git</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#8216;xxx&#8217;&#10;&#10;[master (root-commit) 2e8cda3] Add cute octocat&#10; 1 file changed, 1 insertion(+)&#10; create mode 100644 octocat.txt&#10;&#10;Success!</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>commit</code>:是仓库状态的一个存档，通过<code>commit</code>可以查看提交的所有log<br><code>-m ‘xxx&#39;</code>：每次提交的备注</p>
</blockquote>
<hr>
<ul>
<li>查看提交记录</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log&#10;$ git log --summary</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过<code>--summary</code>查看详细的记录(包括提交作者、时间、备注及每个更改的文件信息)</p>
</blockquote>
<hr>
<ul>
<li>增加一个远程<code>Git</code>仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/try-git/try_git.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个远程仓库，地址为github上提供的地址。并且将该远程仓库命名为origin</p>
</blockquote>
<hr>
<ul>
<li>将本地仓库推送到远程仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>origin是远程仓库的命名，分支默认是master<br><code>-u</code>表示Git会记住Git状态，下次只需要通过<code>git push</code>就可以进行推送</p>
</blockquote>
<hr>
<ul>
<li>从远程<code>Git</code>仓库同步</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将远程仓库同步代码，与本地合并<br><code>git stash</code>：当同步文件时，可能不想将本地的更改覆盖。可以通过stash命令将本地的更改隐藏<br>在同步完成后，再调用<code>git stash apply</code>将本地更改应用到仓库</p>
</blockquote>
<hr>
<ul>
<li>比较缓存区与仓库的代码差异</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HEAD：HEAD是记录不同<code>commit</code>位置的标示，默认的HEAD是最近一次提交的<code>commit</code><br>所以通过HEAD可以快速地确定所在版本，而不需要对比SHA值<br>通过<code>diff</code>命令，可以显示文件之间的冲突</p>
</blockquote>
<hr>
<ul>
<li>重置缓存区的文件</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset xxx.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将缓存区的文件重置到上一次<code>commit</code></p>
</blockquote>
<hr>
<ul>
<li>将缓存区的文件恢复到工作区</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- xxx.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>reset</code>命令重置后，缓存区的文件仍然存在。通过<code>checkout</code>命令将其恢复到工作区</p>
</blockquote>
<hr>
<ul>
<li>创建本地分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>branch</code>命令可以在版本控制中创建一个分支。<br>分支是并发开发的基础，在分支上开发后可以再合并到主分支上。</p>
</blockquote>
<hr>
<ul>
<li>查看分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch&#10;&#10; clean_up&#27;&#10;* &#27;master&#27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>branch</code>命令可以查看本地的分支及当前所在的分支</p>
</blockquote>
<hr>
<ul>
<li>切换分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &#60;branch&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 可以通过git checkout -b <branch>命令同时实现创建+切换分支的操作</branch></p>
</blockquote>
<hr>
<ul>
<li>清空所有仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &#39;*.txt&#39;&#10;$ git rm -r &#60;fold_name&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的命令与Linux命令行相同，支持通配符和递归删除文件夹<br>如果没有通过命令行，直接删除文件的话，还是需要把删除的文件通过<code>git rm</code>命令在<code>Git</code>中删除的。<br>可以在<code>git commit</code>命令中使用<code>-a</code>来自动移除已被删除的文件。例如：`git commit -am <message>‘</message></p>
</blockquote>
<hr>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master&#10;$ git merge clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并分支首选需要切换会朱分支，再通过<code>merge</code>命令合并分支</p>
</blockquote>
<hr>
<ul>
<li>删除分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>branch</code>命令后加入<code>-d</code>表明删除(delete)<br>如果尚未合并，<code>-d</code>命令不会起作用。可以添加<code>-d-f</code>强制删除(force)，或者<code>-D</code></p>
</blockquote>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>http://diov.github.io/2016/01/01/hello/</url>
      <content type="html"><![CDATA[<p>Hello Github!</p>
]]></content>
    </entry>
    
  
  
</search>
