<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[在TextView中自定义HTML样式]]></title>
      <url>http://diov.github.io/2016/03/27/consum-Html-pattern/</url>
      <content type="html"><![CDATA[<p>通常，当我们需要在TextView中显示服务器端返回的Html内容时，就会用到<code>Html.fromHtml(String source)</code>这个方法。Google在源码中默认的为我们提供了对一些Html标签的支持。<br>但是如果我们想要对已有的标签进行自定义展示，或者是有些标签还没有得到支持，那应该怎么做呢？</p>
<a id="more"></a>
<hr>
<h1 id="Html源码分析"><a href="#Html源码分析" class="headerlink" title="Html源码分析"></a>Html源码分析</h1><p>我们知道，使用<code>Html.fromHtml(String source)</code>这个方法时，我们需要将带有Html标签的文本作为参数传递过来。那么在Html这个类中必然会有对不同的标签进行判断，并添加样式的方法。通过查找，主要是由两个方法来完成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStartTag</span><span class="params">(String tag, Attributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"br"</span>)) &#123;</span><br><span class="line">        <span class="comment">// We don't need to handle this. TagSoup will ensure that there's a &lt;/br&gt; for each &lt;br&gt;</span></span><br><span class="line">        <span class="comment">// so we can safely emite the linebreaks when we handle the close tag.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"p"</span>)) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"div"</span>)) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"strong"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Bold());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"b"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Bold());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"em"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Italic());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"cite"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Italic());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"dfn"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Italic());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"i"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Italic());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"big"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Big());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"small"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Small());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"font"</span>)) &#123;</span><br><span class="line">        startFont(mSpannableStringBuilder, attributes);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"blockquote"</span>)) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Blockquote());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"tt"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Monospace());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"a"</span>)) &#123;</span><br><span class="line">        startA(mSpannableStringBuilder, attributes);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"u"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Underline());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"sup"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Super());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"sub"</span>)) &#123;</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Sub());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">               Character.toLowerCase(tag.charAt(<span class="number">0</span>)) == <span class="string">'h'</span> &amp;&amp;</span><br><span class="line">               tag.charAt(<span class="number">1</span>) &gt;= <span class="string">'1'</span> &amp;&amp; tag.charAt(<span class="number">1</span>) &lt;= <span class="string">'6'</span>) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">        start(mSpannableStringBuilder, <span class="keyword">new</span> Header(tag.charAt(<span class="number">1</span>) - <span class="string">'1'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"img"</span>)) &#123;</span><br><span class="line">        startImg(mSpannableStringBuilder, attributes, mImageGetter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTagHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTagHandler.handleTag(<span class="keyword">true</span>, tag, mSpannableStringBuilder, mReader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleEndTag</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"br"</span>)) &#123;</span><br><span class="line">        handleBr(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"p"</span>)) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"div"</span>)) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"strong"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Bold.class, <span class="keyword">new</span> StyleSpan(Typeface.BOLD));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"b"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Bold.class, <span class="keyword">new</span> StyleSpan(Typeface.BOLD));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"em"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Italic.class, <span class="keyword">new</span> StyleSpan(Typeface.ITALIC));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"cite"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Italic.class, <span class="keyword">new</span> StyleSpan(Typeface.ITALIC));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"dfn"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Italic.class, <span class="keyword">new</span> StyleSpan(Typeface.ITALIC));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"i"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Italic.class, <span class="keyword">new</span> StyleSpan(Typeface.ITALIC));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"big"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Big.class, <span class="keyword">new</span> RelativeSizeSpan(<span class="number">1.25f</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"small"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Small.class, <span class="keyword">new</span> RelativeSizeSpan(<span class="number">0.8f</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"font"</span>)) &#123;</span><br><span class="line">        endFont(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"blockquote"</span>)) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">        end(mSpannableStringBuilder, Blockquote.class, <span class="keyword">new</span> QuoteSpan());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"tt"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Monospace.class,</span><br><span class="line">                <span class="keyword">new</span> TypefaceSpan(<span class="string">"monospace"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"a"</span>)) &#123;</span><br><span class="line">        endA(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"u"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Underline.class, <span class="keyword">new</span> UnderlineSpan());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"sup"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Super.class, <span class="keyword">new</span> SuperscriptSpan());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"sub"</span>)) &#123;</span><br><span class="line">        end(mSpannableStringBuilder, Sub.class, <span class="keyword">new</span> SubscriptSpan());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">            Character.toLowerCase(tag.charAt(<span class="number">0</span>)) == <span class="string">'h'</span> &amp;&amp;</span><br><span class="line">            tag.charAt(<span class="number">1</span>) &gt;= <span class="string">'1'</span> &amp;&amp; tag.charAt(<span class="number">1</span>) &lt;= <span class="string">'6'</span>) &#123;</span><br><span class="line">        handleP(mSpannableStringBuilder);</span><br><span class="line">        endHeader(mSpannableStringBuilder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTagHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTagHandler.handleTag(<span class="keyword">false</span>, tag, mSpannableStringBuilder, mReader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Html标签总是成对出现，所以有<code>handleStartTag</code>和<code>HandleEndTag</code>两个方法。<br>其实在这两个方法中，都是对一些标签进行了判断，在调用<code>start(SpannableStringBuilder text, Class kind, Object repl)</code>和<code>end(SpannableStringBuilder text, Class kind, Object repl)</code>这两个方法。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(SpannableStringBuilder text, Object mark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = text.length();</span><br><span class="line">    text.setSpan(mark, len, len, Spannable.SPAN_MARK_MARK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(SpannableStringBuilder text, Class kind,</span><br><span class="line">                        Object repl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = text.length();</span><br><span class="line">    Object obj = getLast(text, kind);</span><br><span class="line">    <span class="keyword">int</span> where = text.getSpanStart(obj);</span><br><span class="line"></span><br><span class="line">    text.removeSpan(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (where != len) &#123;</span><br><span class="line">        text.setSpan(repl, where, len, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个方法中，最核心的代码就是<code>SpannableStringBuilder.setSpan(Object what, int start, int end, int flags)</code>。</p>
<blockquote>
<p>Mark the specified range of text with the specified object. The flags determine how the span will behave when text is inserted at the start or end of the span’s range.</p>
</blockquote>
<p>通过查阅文档，我们可以知道这个方法是将text中指定的区域添加上样式，flag参数决定在指定范围前后插入文本时是否采用同样的样式</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>现在我们知道了<code>Html.fromHtml</code>是如何来实现对Html标签的解析并且添加上样式。那么如何来解决我们最开始提出的问题呢？</p>
<ul>
<li>例： 搜索指定字段，服务器返回的搜索结果中，将字段添加<em>标签返回。此时使用<code>Html.from</code>默认的样式是斜体，而我们需要给字段添加背景为黄色的高亮。</em></li>
</ul>
<blockquote>
<p> ‘em’ 标签告诉浏览器把其中的文本表示为强调的内容。对于所有浏览器来说，这意味着要把这段文字用斜体来显示。<br>除强调之外，当引入新的术语或在引用特定类型的术语或概念时作为固定样式的时候，也可以考虑使用 ‘em’ 标签。</p>
</blockquote>
<h2 id="替换样式"><a href="#替换样式" class="headerlink" title="替换样式"></a>替换样式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Spannable source = (Spannable) Html.fromHtml(content);</span><br><span class="line">  <span class="keyword">final</span> StyleSpan[] styleSpans = source.getSpans(<span class="number">0</span>, source.length(), StyleSpan.class);</span><br><span class="line">  <span class="keyword">if</span> (styleSpans != <span class="keyword">null</span> &amp;&amp; styleSpans.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (StyleSpan styleSpan : styleSpans) &#123;</span><br><span class="line">          <span class="keyword">if</span> (Typeface.ITALIC == styleSpan.getStyle()) &#123;</span><br><span class="line">              source.setSpan(<span class="keyword">new</span> BackgroundColorSpan(Color.YELLOW), source.getSpanStart(styleSpan),</span><br><span class="line">                      source.getSpanEnd(styleSpan), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">              source.removeSpan(styleSpan);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>setSpan</code>和<code>removeSpan</code>，我们将原有的<code>StyleSpan(Typeface.ITALIC)</code>移除，转而替换为<code>BackgroundColorSpan</code>。</p>
<h2 id="自定义TagHandler"><a href="#自定义TagHandler" class="headerlink" title="自定义TagHandler"></a>自定义TagHandler</h2><p>使用重载的<code>Html.fromHtml(String source, ImageGetter imageGetter, TagHandler tagHandler)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTagHandler</span> <span class="keyword">implements</span> <span class="title">TagHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sIndex = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> eIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MxgsaTagHandler</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        mContext=context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTag</span><span class="params">(<span class="keyword">boolean</span> opening, String tag, Editable output, XMLReader xmlReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag.toLowerCase().equals(<span class="string">"eem"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opening) &#123;</span><br><span class="line">                sIndex=output.length();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                eIndex=output.length();</span><br><span class="line">                output.setSpan(<span class="keyword">new</span> BackgroundColorSpan(Color.YELLOW), source.getSpanStart(styleSpan),</span><br><span class="line">                        source.getSpanEnd(styleSpan), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用自定义的TagHandler时需要注意的一点是，因为<code>Html.fromHtml</code>会先调用默认的逻辑来添加样式，此时是不会调用到我们自己实现的TagHandler中的逻辑的。这时候我们只能先将初始文本通过正则表达式进行替换。<br>所以当<code>Html</code>类中没有进行处理的Html标签，再考虑使用自定义TagHandler会是一个更好的选择。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从AIDL浅析Binder机制]]></title>
      <url>http://diov.github.io/2016/03/20/A-Brief-Analysis-on-AIDL-of-Binder/</url>
      <content type="html"><![CDATA[<p>AIDL(Android Interface Defination Language),Android接口定义语言。是Google专门为Android中跨进程调用服务所设计的一种接口语言。<br>其本质是Android中特有的一种IPC机制：Binder机制。通过对AIDL的分析我们也可以对Binder机制有所了解</p>
<a id="more"></a>
<h1 id="AIDL的使用"><a href="#AIDL的使用" class="headerlink" title="AIDL的使用"></a>AIDL的使用</h1><p>首先让我们简单回顾一下AIDL是如何使用的。下面的操作基于Android Studio。</p>
<ul>
<li>创建AIDL文件<br>在Project视图下，在/src/main/下创建与java同级的aidl文件夹，并在该文件夹下创建包名(例:com.example.diov.testaidl),在该文件夹下创建AIDL文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.diov.testaidl;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestAidl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个接口文件中定义Service需要实现的方法。   </p>
<ul>
<li>实现AIDL中的方法<br>创建完AIDL文件后，通过Gradle编译。编译成功后可以在/generated/source/debug/{packagename}/下找到生成的TestAidl.java文件。<br>然后我们回到Service中，实现AIDL接口中定义的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IRemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定服务时将IBinder对象返回出去</span></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iBinder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> IBinder iBinder = <span class="keyword">new</span> TestAidl.Stub()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">      <span class="comment">// 具体实现</span></span><br><span class="line">      <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用AIDL<br>在Client里按照第一步，把相同的AIDL文件创建出来。<br>绑定Service需要调用<code>bindService(Intent intent, ServiceConnection conn, int flag)</code>方法。<br>这里主要是实现ServiceConnection接口，在这个接口的回调方法中就可以得到对应的服务所提供IBinder对象了   </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">private TestAidl aidl;</span><br><span class="line">private ServiceConnection conn = new ServiceConnection&#123;</span><br><span class="line">  // 绑定成功时回调</span><br><span class="line">  @Override</span><br><span class="line">  public void onServiceConnected(ComponentName name, IBinder service)&#123;</span><br><span class="line">    // 获取到了远程服务</span><br><span class="line">    aidl = TestAidl.Stub.asInterface(service);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 解除绑定时回调</span><br><span class="line">  @Override</span><br><span class="line">  public void onServiceDisconnected(ComponentName name)&#123;</span><br><span class="line">    aidl = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">获取到IBinder对象后，就可以实现IPC，调用远程服务了。</span><br><span class="line"></span><br><span class="line"># AIDL的实现原理 #   </span><br><span class="line">现在来看看AS自动帮我们生成的TestAdil.java这个文件</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package com.example.diov.testaidl;</span><br><span class="line"></span><br><span class="line">public interface TestAidl extends android.os.IInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存根类，实现了Binder和TestAidl接口(IInterface接口)</span><br><span class="line">     */</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.example.dio_v.materialdemo.TestAidl &#123;</span><br><span class="line">        private static final java.lang.String DESCRIPTOR = "com.example.dio_v.materialdemo.TestAidl";</span><br><span class="line"></span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 将IBinder对象转换成com.example.diov.testaidl.TestAidl接口,</span><br><span class="line">         * 如果需要的话生成一个代理.</span><br><span class="line">         */</span><br><span class="line">        public static com.example.dio_v.materialdemo.TestAidl asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj == null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin != null) &amp;&amp; (iin instanceof com.example.dio_v.materialdemo.TestAidl))) &#123;</span><br><span class="line">                return ((com.example.dio_v.materialdemo.TestAidl) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.example.dio_v.materialdemo.TestAidl.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当Client调用Service时，获取代理类发送过来的数据</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws</span><br><span class="line">                android.os.RemoteException &#123;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_add: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    int _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    int _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line"></span><br><span class="line">                    // 通过子类来实现方法中具体的操作，并将结果通过reply对象返回出去</span><br><span class="line">                    int _result = this.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 代理类，实现了TestAidl接口(IInterface接口)</span><br><span class="line">        private static class Proxy implements com.example.dio_v.materialdemo.TestAidl &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int add(int i, int j) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                int _result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 通过序列化将参数发送</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(i);</span><br><span class="line">                    _data.writeInt(j);</span><br><span class="line"></span><br><span class="line">                    // 通过Framework将序列化后的参数发送给IBinder对象</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line"></span><br><span class="line">                    // 通过返回的reply将Service返回的结果解析出来</span><br><span class="line">                    _result = _reply.readInt();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 接口中的方法</span><br><span class="line">    public int add(int i, int j) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在Client中绑定Service，会通过<code>TestAdil.Stub.asInterface()</code>方法去转换返回的IBinder对象(Stub继承的Binder类是IBinder接口的实现类),得到的是一个Proxy类对象   </li>
<li>Proxy类将参数序列化之后，通过Framework将参数发送给<code>Service.onBind()</code>返回的IBinder对象   </li>
<li>Service中返回的IBinder对象(Stub对象)，通过具体实现来完成对参数的操作，并且将返回值封装在一个Parcel对象中   </li>
<li>Framework层将封装后的Parcel对象再返回给Proxy对象   </li>
<li>Proxy对象从Parcel对象中获取返回值   </li>
</ol>
<h1 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h1><p>其实在Binder机制中存在一个重要的角色，ServiceManager，他是Service和Client中IPC交互的重要一环。ServiceManager负责在Framework层将参数传递、返回Proxy对象等等</p>
<p>而在Client，并不是真正持有了Service中的对象，而是通过ServiceManager，借助Proxy对象来完成跨进程通信。所以说Binder机制使用的其实就是/代理模式/。</p>
<p>对于Binder机制，我也还只是对概念有初步的了解。想要深入了解Binder机制，还需要继续学习。</p>
<hr>
<blockquote>
<p>资料推荐：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[setContentView和findViewById的源码解析]]></title>
      <url>http://diov.github.io/2016/03/08/setContentView-findViewById/</url>
      <content type="html"><![CDATA[<p>最近在面试的时候有碰到这样一个问题，就是“View.inflate()和View.findViewById()哪个更耗时，为什么”。通过之前对于<a href="http://diov.github.io/2016/02/15/From_XML_to_View/">View.inflate()源码的分析</a>，可以知道在将布局文件转化为View对象的时候需要通过io读取文件+遍历解析XML文件+生成每一个View对象，而findViewById()只是遍历View树来获取对应的View对象。所以很明显应该是View.inflate()更为耗时。</p>
<p>那么，findViewById()究竟是如何通过id来获取对应的View对象的呢？我们今天从<code>Activity.setContentView()</code>和<code>Activity.findViewById()</code>的源码谈起</p>
<a id="more"></a>
<h1 id="Activity-setContentView-int-layoutResID"><a href="#Activity-setContentView-int-layoutResID" class="headerlink" title="Activity.setContentView(int layoutResID)"></a>Activity.setContentView(int layoutResID)</h1><p>在使用Activity时，都会在onCreate()中通过<code>setContentView()</code>给Activity设置布局</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到里面做了两件事：</p>
<ol>
<li>获取Window对象，并调用Window的setContentView()</li>
<li>设置ActionBar</li>
</ol>
<h2 id="PhoneWindow-setContentView-int-layoutResID"><a href="#PhoneWindow-setContentView-int-layoutResID" class="headerlink" title="PhoneWindow.setContentView(int layoutResID)"></a>PhoneWindow.setContentView(int layoutResID)</h2><p>我们只关注前者。Window是一个抽象类，他具体的实现大多在<em>PhoneWindow</em> 这个实现类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化DecorView</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过LayoutInflater将布局文件添加到 mContentParent中</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activity 实现了Window.Callback接口.</span></span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断mContentParent，如果为null就初始化，否则将其所有的View移除。然后通过LayoutInflater把布局文件添加到mContentParent中。之后还获取了一个Calback对象，来进行回调。而这个Callback对象正是Activity，他实现了Callback接口，需要我们自己去实现onContentChanged()方法</p>
<h2 id="PhoneWindow-installDecor"><a href="#PhoneWindow-installDecor" class="headerlink" title="PhoneWindow.installDecor()"></a>PhoneWindow.installDecor()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 省略代码，根据style和其他一些属性去设置title、icon等等</span><br><span class="line">         */</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mTitleView = (TextView)findViewById(R.id.title);</span><br><span class="line">            <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTitleView.setLayoutDirection(mDecor.getLayoutDirection());</span><br><span class="line">                <span class="comment">// 为什么需要在setContentView()之前调用requestWindowFeature()</span></span><br><span class="line">                <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTitleView.setText(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道在Android的每个页面中，都会由系统来初始化一个根布局DecorView，它是FrameLayout的子类。事实上就是在<code>installDecor()</code>方法里面进行的。可以看到首先调用了<code>generateDecor()</code>来实例化了一个DecorView，然后通过<code>generateLayout(mDecor)</code>生成了mContentParent。此后会通过我们给Activity设置的style和属性对DDecorView进行初始化。在这里有一点需要注意的，就是我们都知道，如果要设置Activity无标题，需要在setContentView()之前调用requestWindowFeature(FEATURE_NO_TITLE)，在源码中我们可以找到答案。</p>
<blockquote>
<p>关于Android页面的实际布局，可以使用SDK的tools中的hierarchy viewer工具自行查看了解</p>
</blockquote>
<h2 id="PhoneWindow-generateDecor"><a href="#PhoneWindow-generateDecor" class="headerlink" title="PhoneWindow.generateDecor()"></a>PhoneWindow.generateDecor()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Apply data from current theme.</span></span><br><span class="line">     TypedArray a = getWindowStyle();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span><br><span class="line">      * 通过获取的theme来设置根布局</span><br><span class="line">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据theme来获取指定的布局文件，添加到DecorView中</span></span><br><span class="line">      View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">      decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">      mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不论是那种跟布局文件，都可以ID_ANDROID_CONTENT来获取一个contentParent</span></span><br><span class="line">      <span class="comment">// 就是我们可以自己去填充内容的FrameLayout</span></span><br><span class="line">      ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span><br><span class="line">       * 省略</span><br><span class="line">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generateDecor()仅仅是返回一个DecorView对象。而在generateLayout()中，可以看到通过TypedArray去获取我们在XML中给Activity定义的theme和style，根据这些属性决定最终的使用是哪个布局。最终返回的是布局文件中id为ID_ANDROID_CONTENT的FrameLayout对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们基本把<code>Activity.setContentView()</code>的流程搞清楚了。</p>
<ol>
<li>通过Window对象创建DecorView对象</li>
<li>在DecorView中根据Activity的theme和style创建根布局、title等</li>
<li>通过LayoutInflater将自定义的布局文件转化为View对象，添加到根布局中作为内容的FrameLayout中</li>
<li>LayoutInflater.inflate()依次向下遍历，直到生成整个View树</li>
</ol>
<hr>
<h1 id="Activity-findViewById-int-id"><a href="#Activity-findViewById-int-id" class="headerlink" title="Activity.findViewById(int id)"></a>Activity.findViewById(int id)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getWindow().findViewById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到<code>findViewById()</code>的源码我想你也会会心一笑，他跟<code>setContentView()</code>真的很像，同样是由Window这个类区来实现</p>
<h2 id="Window-findViewById"><a href="#Window-findViewById" class="headerlink" title="Window.findViewById()"></a>Window.findViewById()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDecorView().findViewById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面我们对<code>setContentView()</code>的分析，可以直到getDecorView()其实就是返回页面上最顶端的ViewGroup对象，从上向下去findViewById(int id)找到指定的子控件</p>
<h2 id="View-findViewById"><a href="#View-findViewById" class="headerlink" title="View.findViewById()"></a>View.findViewById()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findViewTraversal(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View.findViewById()实际上是调用findViewTraversal()方法。这个方法就是根据id决定返回的是View自身还是null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">findViewTraversal</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == mID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经直到，DecorView是FrameLay的子类。所以向下遍历findViewById()的核心应该实在ViewGroup这个View的子类中。</p>
<p>而ViewGroup只重写了findViewTraversal()方法</p>
<h2 id="ViewGroup-findViewTraversal-int-id"><a href="#ViewGroup-findViewTraversal-int-id" class="headerlink" title="ViewGroup.findViewTraversal(int id)"></a>ViewGroup.findViewTraversal(int id)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">findViewTraversal</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == mID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View[] where = mChildren;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = mChildrenCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        View v = where[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="number">0</span>) &#123;</span><br><span class="line">            v = v.findViewById(id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup首先也是判断自身的mID与参数id是否相等，来决定是否需要返回自身。之后，可以看到在ViewGroup中维护了一个View[]数组，用来存储所有的子控件。遍历这些子控件，再调用子控件的findViewById()向下遍历，直到找到指定id的View对象。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><code>Activity.findViewById()</code>的流程相对简单很多</p>
<ol>
<li>首先获取Window对象，通过该对象得到DecorView对象</li>
<li>由DecorView对象向下，通过ViewGroup.findViewById()（调用父类View方法） -&gt; ViewGroup.findViewTraversal() -&gt; View.findViewById() -&gt; View.findViewTraversal() 依次遍历整个View树，找到View对象</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义CoordinatorLayout.Behavior]]></title>
      <url>http://diov.github.io/2016/03/02/Consum-Behavior-to-response-CoordinatorLayout-scroll/</url>
      <content type="html"><![CDATA[<p>在Design Support Library中，Google为我们提供了一系列实现Material Design的控件：TextInputLayout、NavigationView、FloatingActionButton等。</p>
<p><a href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">CoordinatorLayout</a>，为我们处理触摸事件提供了一种新的方式。在CoordinatorLayout的使用中，最为核心的就是CoordinatorLayout.Behavior这个内部类了</p>
<a id="more"></a>
<h1 id="从CoordinatorLayout开始"><a href="#从CoordinatorLayout开始" class="headerlink" title="从CoordinatorLayout开始"></a>从CoordinatorLayout开始</h1><blockquote>
<p>CoordinatorLayout is a super-powered FrameLayout.<br>CoordinatorLayout is intended for two primary use cases:</p>
<ol>
<li>As a top-level application decor or chrome layout</li>
<li>As a container for a specific interaction with one or more child views</li>
</ol>
</blockquote>
<p>从开发者文档的描述中我们可以知道，CoordinatorLayout是一个加强版的FrameLayout，他有两个主要作用：</p>
<pre><code>1. 作为根布局
2. 用于处理一个或多个子控件之间特殊的交互的容器
</code></pre><p>何为多个子控件之间的交互呢？在之前的博客（<a href="http://diov.github.io/2016/01/17/Analisis_of_Touchevent_in_Android/">ANDROID 触摸事件分发源码</a>）中有提及，在ViewGroup处理触摸事件时，只会在ACTION_DOWN的时候去判断哪一个子控件可以接收处理事件；当某一个子控件可以处理ACTION_DOWN事件时，后续的一系列手势会直接传递到该控件，其他子控件是无法直接响应触摸事件的。</p>
<p>如果我们需要某个子控件监听另一个子控件、或者监听父控件的滚动，并做出响应？通常我们会定义一个接口，通过接口的回调在另一个控件中修改属性。</p>
<p>而现在，可以直接通过CoordinatorLayout对这些控件进行包裹，来处理这些子控件之间的交互</p>
<h1 id="CoordinatorLayout-Behavior"><a href="#CoordinatorLayout-Behavior" class="headerlink" title="CoordinatorLayout.Behavior"></a>CoordinatorLayout.Behavior</h1><p>那么，怎样才能在CoordinatorLayout中进行子控件之间的交互呢？这就需要我们来自定义不同的CoordinatorLayout.Behavior了</p>
<p>Behavior是CoordinatorLayout的内部类，在这个类的内部提供了一系列的回调方法：</p>
<ol>
<li><code>layoutDependsOn()</code>：将两个控件绑定起来，child监听dependency</li>
<li><code>onDependentViewChanged()</code>：在dependency状态改变时回调</li>
<li><code>onStartNestedScroll ()</code>：根据返回值来决定是否要处理这次neast scroll</li>
<li><code>onNestedPreScroll()</code>： 在子控件响应滑动之前回调</li>
<li><code>onNestedScroll()</code>：子控件响应滑动时回调</li>
<li><code>onNestedPreFling()</code>|<code>onNestedFling()</code>：惯性滑动</li>
</ol>
<p>主要需要重写的就是这些方法，通常</p>
<ol>
<li>如果需要让某个控件监听另一个控件的状态，需要重写<code>layoutDependsOn()</code>和<code>onDependentViewChanged()</code>方法</li>
<li>如果需要让某个控件监听父控件的滑动，需要重写另外四个方法中的部分或全部</li>
</ol>
<h1 id="自定义一个Beahavior"><a href="#自定义一个Beahavior" class="headerlink" title="自定义一个Beahavior"></a>自定义一个Beahavior</h1><p>现在我们有这么一个需求，在CoordinatorLayout中有一个RecyclerView和一个FAB，需要在RecyclerView下滑时隐藏FAB、上滑时显示FAB。现在大多数使用Material Design的App都会有这么一个需求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollBehavior</span> <span class="keyword">extends</span> <span class="title">CoordinatorLayout</span>.<span class="title">Behavior</span>&lt;<span class="title">FloatingActionButton</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于需要在布局文件中使用，所以必须重写这个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScrollBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                                       <span class="keyword">final</span> View directTargetChild, <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对垂直方向的滑动进行处理</span></span><br><span class="line">        <span class="keyword">return</span> nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL ||</span><br><span class="line">                <span class="keyword">super</span>.onStartNestedScroll(coordinatorLayout, child, directTargetChild,</span><br><span class="line">                        target, nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child, <span class="keyword">final</span></span><br><span class="line">    View target, <span class="keyword">final</span> <span class="keyword">int</span> dxConsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyConsumed, <span class="keyword">final</span> <span class="keyword">int</span> dxUnconsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed,</span><br><span class="line">                dxUnconsumed, dyUnconsumed);</span><br><span class="line">        <span class="keyword">if</span> (dyConsumed &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                child.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// 用户向下滑，并且FAB是VISIBLE时 -&gt; hide the FAB</span></span><br><span class="line">            child.hide();</span><br><span class="line">            child.setVisbility(View.GONE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dyConsumed &lt; <span class="number">0</span> &amp;&amp; child.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// 用户向上滑，并且FAB当前不是VISIBLE时 -&gt; show the FAB</span></span><br><span class="line">            child.setVisbility(View.VISIBLE);</span><br><span class="line">            child.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义Behavior之后，在布局文件中给FloatingActionButton添加上属性，就可以实现想要的UI了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">android.support.design.widget.CoordinatorLayout</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/main_content"</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.v7.widget.RecyclerView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/recyclerView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.design.widget.FloatingActionButton</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/fab"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_gravity</span>=<span class="value">"bottom|right"</span></span><br><span class="line">        <span class="attribute">android:layout_margin</span>=<span class="value">"16dp"</span></span><br><span class="line">        <span class="attribute">android:src</span>=<span class="value">"@android:drawable/ic_dialog_email"</span></span><br><span class="line">        <span class="attribute">app:layout_behavior</span>=<span class="value">".ScrollBehavior"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要注意的是，在CoordinatorLayout中，使用ListView或者GridView作为传递滑动的控件是不能响应CoordinatorLayout.Behavior的。<br>似乎是因为ListView和GridView中没有添加相关的代码。使用RecyclerView就可以了</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从ListView的嵌套来理解onMeasure方法]]></title>
      <url>http://diov.github.io/2016/02/28/knowledge-about-onMeasure-from-ListView-height-problem/</url>
      <content type="html"><![CDATA[<p>在Google提供的控件中，有一系列支持触摸滚动的原生控件：ScrollView、ListView、GridView。尽管Google并不推荐我们将这些可滚动的控件进行嵌套使用，但是难免会有业务要求。这时通常会遇到两种问题：</p>
<ol>
<li>当设置内层的控件的高度为match_parent或者wrap_content时，高度不正常</li>
<li>触摸事件冲突<br>对于触摸事件的冲突可以参考我之前对于View中触摸事件的分发的分析来进行解决<a href="http://diov.github.io/2016/01/17/Analisis_of_Touchevent_in_Android/">ANDROID 触摸事件分发源码</a>。这里我们来分析一下为何会出现高度不正常。</li>
</ol>
<a id="more"></a>
<h1 id="先来解决问题"><a href="#先来解决问题" class="headerlink" title="先来解决问题"></a>先来解决问题</h1><p>先来看看如何解决ScrollView嵌套ListView的高度问题吧。</p>
<p>通常常用的有两种方法：</p>
<ol>
<li>在ListView设置Adapter之后，获取每一个View，测量每一个View的高度从而得到ListView总的高度，再手动设置</li>
<li>重写ListView的<code>onMeasure</code>方法</li>
</ol>
<p>第一种方法我们这里暂且不谈，其实就是通过<code>ListAdapter.getView()</code>获取相应的View对象再进行测量。相对比较简单，可以去网上自行查找</p>
<p>这里我们来看看第二种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> expandSpec = MeasureSpec.makeMeasureSpec(Integer.Max &gt;&gt; <span class="number">2</span>,</span><br><span class="line">            , MeasureSpec.AT_MOST);</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重写<code>onMeasure()</code>方法后就可以让ListView的高度恢复正常了</p>
<h1 id="onMeasure-源码分析"><a href="#onMeasure-源码分析" class="headerlink" title="onMeasure 源码分析"></a>onMeasure 源码分析</h1><p>每个View的绘制过程都会经历<code>measure()</code>-&gt;<code>layout()</code>-&gt;<code>draw()</code>这样一个流程，在<code>measure()</code>方法中我们对View的宽高进行测量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * The actual measurement work of a view is performed in onMeasure(int, int), called by this method.</span><br><span class="line"> * Therefore, only onMeasure(int, int) can and must be overridden by subclasses.  </span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>measure()</code>方法是一个final方法，表明子类无法去重写该方法的。在其中调用了<code>onMeasure()</code>方法，在这个方法中完成实际的测量工作，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onMeasure()</code>方法中调用了<code>setMeasuredDimension()</code>，从方法名就可以看出来这是将测量后的宽高值设置给当前的View的方法</p>
<p>在<code>getSuggestedMInimumWidth()</code>中，会判断View是否添加了background。如果没有设置background，会返回android:minWidth属性下设置的值；否则返回的就是android:minWidth和background的较大值</p>
<p>而在<code>getDefaultSize()</code>中，则是根据父控件传递下来的MeasureSpec和<code>getSuggestedMinimumWidth()</code>方法返回的值计算出最终的测量值</p>
<blockquote>
<p> 此外ViewGroup的测量过程是<code>measureChildren()</code>-&gt;<code>measureChild()</code>-&gt;<code>child.measure()</code>，依次向下遍历，将所有的子控件进行测量。感兴趣的可以自行查看ViewGroup的源码</p>
</blockquote>
<h1 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h1><p>在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>中我们对View的宽高进行了测量，那么究竟是如何进行测量的呢？从两个参数名可以看出来，肯定是与测量宽高有关的两个int值。</p>
<p>这里就涉及到View的一个静态内部类 MeasureSpec 了，先来看一看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MeasureSpec的三种模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT; <span class="comment">// 想要多大就多大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT; <span class="comment">// 精确大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT; <span class="comment">// 确定最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Mode和Sie去生成MeasureSpec对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;&lt;!</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Mode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Size</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = getSize(measureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></span><br><span class="line">            <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        size += delta;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</span><br><span class="line">                    <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 省略</span><br><span class="line">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MeasureSpec代表了测量的标准，实际上是一个32位的二进制的值，其中30～31位代表了测量的模式：UNSPECIFIED(0x00)、EXACTLY(0x01)和AT_MOST(0x02)，而0~29位封装了测量的大小</p>
<p>此外，在MeasureSpec的<code>makeMeasureSpec()</code>方法中，通过传入代表模式和大小的值，通过位运算我们就可以得到指定的MeasureSpec对象了</p>
<p>那么每个View在调用<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>时，方法中的参数时哪里的来的呢？我们已经知道了，触摸事件的分发是由根节点的ViewGroup依次向下传递，其实View的测量也是这样由根节点依次测量子控件（也就是上面提到的ViewGroup的测量过程），而作为参数传递的MeasureSpec就是由父控件传来的</p>
<table>
<thead>
<tr>
<th style="text-align:center">父控件属性</th>
<th style="text-align:center">子控件属性</th>
<th style="text-align:center">子控件的MeasureSpec</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EXACTLY+size</td>
<td style="text-align:center">dp</td>
<td style="text-align:center">EXACTLY+dp</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">match_parent</td>
<td style="text-align:center">EXACTLY+size</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wrap_content</td>
<td style="text-align:center">AT_MOST+size</td>
</tr>
<tr>
<td style="text-align:center">AT_MOST+size</td>
<td style="text-align:center">dp</td>
<td style="text-align:center">EXACTLY+dp</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">match_parent</td>
<td style="text-align:center">AT_MOST+size</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wrap_content</td>
<td style="text-align:center">AT_MOST+size</td>
</tr>
<tr>
<td style="text-align:center">UNSPECIFIED+size</td>
<td style="text-align:center">dp</td>
<td style="text-align:center">EXACTLY+dp</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">match_parent</td>
<td style="text-align:center">UPSPECIFIED+0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wrap_content</td>
<td style="text-align:center">UPSPECIFIED+0</td>
</tr>
</tbody>
</table>
<p>所以最终的MeasureSpec是由父控件的测量时得到的MeasureSpec与当前View的属性来决定的。这也是我们之前在<a href="http://diov.github.io/2016/02/15/From_XML_to_View/">LayoutInflater填充XML布局文件时</a>留下的问题，为什么必须要通过父控件才能使当前View的LayoutParams生效，原因也在这里了。</p>
<h1 id="解决高度的原理"><a href="#解决高度的原理" class="headerlink" title="解决高度的原理"></a>解决高度的原理</h1><p>回过头来再看看我们一开始解决ListView高度的解决方式，在重写的<code>onMeasure()</code>方法中，我们通过<code>MeasureSpec.makeMeasureSpec()</code>方法，手动的生成了一个AT_MOST+size的 MeasureSpec。这样就避免了系统由于两层可滚动的控件嵌套导致的测量错误。当然，这里的size使用的是<code>Integer.MAX &gt;&gt; 2</code>，获得的值是远远大于屏幕的高度的，所以最终显示的高度还是只有屏幕高度这样</p>
<p>如果我们使用Debug工具在<code>onMeasure()</code>中获取父控件传递过来的MeasureSpec对象，会发现其实这时候的heightMeasureSpec的值是0，也就是MODE为UNSPECIFIED，size为0。既然是这样为什么还是可以显示ListView中一个element的高度呢？</p>
<p>原来在ListView的<code>onMeasure()</code>方法中，对最低的高度进行了计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (heightMode == MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">    heightSize = mListPadding.top + mListPadding.bottom + childHeight +</span><br><span class="line">            getVerticalFadingEdgeLength() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在不设置padding的情况下，默认得到的高度正好就是一个element的高度。这就是我们不重写默认显示的情况了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从XML到View]]></title>
      <url>http://diov.github.io/2016/02/15/From_XML_to_View/</url>
      <content type="html"><![CDATA[<p>通常，我们会将应用中需要展示的界面内容都写在XML文件中，通过<code>Activity</code>的<code>setContentView()</code>方法设置。<br>当我们希望动态的添加一个没有被加载的xml布局文件，比如在<code>ViewPager</code>或者是<code>ListView</code>中，就需要使用到<code>View.inflate()</code>方法或者是<code>LayoutInflater</code>这个类。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h1 id="获取LayoutInflater实例"><a href="#获取LayoutInflater实例" class="headerlink" title="获取LayoutInflater实例"></a>获取LayoutInflater实例</h1><p>先来看一下<code>View.inflate()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">inflate</span><span class="params">(Context context, @LayoutRes <span class="keyword">int</span> resource, ViewGroup root)</span> </span>&#123;</span><br><span class="line">    LayoutInflater factory = LayoutInflater.from(context);</span><br><span class="line">    <span class="keyword">return</span> factory.inflate(resource, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是封装了<code>LayoutInflater</code>的<code>from(Context context)</code>方法，并通过获取的<code>LayoutInflater</code>实例来返回<code>View</code>对象</p>
<p>那么如何能获取到<code>LayoutInflater</code>对象的实例呢？通常有三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater layoutInflater = Activity.<span class="keyword">this</span>.getLayoutInflater(); <span class="comment">// 该方法只能由Activity的实例来调用</span></span><br><span class="line">LayoutInflater layoutInflater = LayoutInflater.from(Context context);</span><br><span class="line">LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure>
<p>第一种方法只能由Activity的实例来调用，内部实际上是调用了<code>Window</code>接口的<code>getLayoutInflater()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">getLayoutInflater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getWindow().getLayoutInflater();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的实现在<code>PhoneWindow</code>类中，通过<code>LayoutInflater.from(Context context)</code>来返回实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PhoneWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    mLayoutInflater = LayoutInflater.from(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">getLayoutInflater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    LayoutInflater LayoutInflater =</span><br><span class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以三种方法实际上是以同样的代码来实现的。</p>
<h1 id="从XML到View"><a href="#从XML到View" class="headerlink" title="从XML到View"></a>从XML到View</h1><p>首先明确一下，一般在布局文件中，我们都必须给每一个控件添加两个属性：<code>layout_height</code>和<code>layout_width</code>，通过这两个属性来控制控件的宽高。但是为什么有时候，通过<code>inflate()</code>方法将其转换为View之后，两个属性就不起作用了呢？  </p>
<h2 id="从inflate-开始"><a href="#从inflate-开始" class="headerlink" title="从inflate()开始"></a>从inflate()开始</h2><p>获取到<code>LayoutInflater</code>的实例之后，就可以调用<code>layoutInflater.inflate()</code>方法将XML布局文件转换成View对象了。</p>
<p><code>inflate()</code>方法有多个重载，先来看看这些重载有什么不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终这些重载的方法都调用了<code>inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删掉了一些不关心的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="comment">// 1. 先将rootView赋值给result</span></span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 开始通过Pull解析对XML文件进行解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析根节点，从START_TAG开始解析</span></span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription() + <span class="string">": No start tag found!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// XML根标签为&lt;merge&gt;，优化XML时使用</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                            + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将XML文件的根节点转化为View对象，赋值给temp</span></span><br><span class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果root不为null，就根据父控件及XML中配置的属性来生成LayoutParams</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// 如果不需要将当前View添加到父控件中，就直接设置参数</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 依次遍历，将XML中所有的控件转换为View对象</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果root不为null，并且要将转换后的View对象添加到父控件中，就直接调用addView()方法</span></span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 决定返回的View时root(父控件)或者是XML中换换后的控件</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回View对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉整个源码之后，我们再回头来看一看就清晰明了了：</p>
<ol>
<li><code>inflate(resource, null)</code> : 如果root为null，那么不论第三个参数存在与否、是否为true，在XML文件中设置的关于布局的属性就都不会生效</li>
<li><code>inflate(resource, root, false)</code> : 如果root不为null，但是不将XML转换的View添加到root下，那么XML文件中设置的属性生效，返回的是XML的根节点生成的View对象</li>
<li><code>inflate(resource, root, true)</code> : 如果root不为null，并且将转换的View添加到root下，那么返回的是添加View对象后的root  </li>
</ol>
<p>此外，从源码中我们可以知道，如果在一个XML布局文件中，我们将根节点设置为<code>&lt;merge&gt;</code>的话，必须存在一个父控件将其包裹，否则就会抛出异常</p>
<blockquote>
<p>至于为什么必须要存在父控件，子View的LayoutParams才能生效，我会在后面的文章中解释。</p>
</blockquote>
<h2 id="createViewFromTag-的实现"><a href="#createViewFromTag-的实现" class="headerlink" title="createViewFromTag()的实现"></a>createViewFromTag()的实现</h2><p>在<code>inflate()</code>中，是通过<code>createViewFromTag()</code>将XML中的标签转换为一个View对象的，那么他是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删掉了一些不关心的代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs, <span class="keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在布局文件中我们可以将标签设置为&lt;view&gt;，通过class属性设置具体的控件</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</span><br><span class="line">            name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">            <span class="comment">// 从Theme中获取属性</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            View view;</span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 如果控件名中不包含'.'，表明是系统的控件</span></span><br><span class="line">                        view = onCreateView(parent, name, attrs);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则为自定义的控件</span></span><br><span class="line">                        view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分别调用了<code>onCreateView()</code>和<code>createView()</code>方法，而最终调用的是<code>createView(String name, String prefix, AttributeSet attrs)</code>中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删掉了一些不关心的代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, AttributeSet attrs)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onCreateView(name, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createView(name, <span class="string">"android.view."</span>, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object[] args = mConstructorArgs;</span><br><span class="line">        args[<span class="number">1</span>] = attrs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> View view = constructor.newInstance(args);</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] mConstructorSignature = <span class="keyword">new</span> Class[] &#123;Context.class, AttributeSet.class&#125;;</span><br></pre></td></tr></table></figure>
<p>其实核心代码还是比较简单的，就是通过反射来获取两个参数（mConstructorSignature）的构造器，再调用<code>newInstance()</code>方法构造出需要的<code>View</code>对象。这也是为什么如果我们使用自定义控件时，如果需要通过XML文件来使用必须复写有两个参数的构造函数的原因。</p>
<h2 id="rInflateChildren-的实现"><a href="#rInflateChildren-的实现" class="headerlink" title="rInflateChildren()的实现"></a>rInflateChildren()的实现</h2><p>通过<code>createViewFromTag()</code>将XML文件中的标签转换为<code>View</code>对象后，就要调用<code>rInflateChildren()</code>将布局文件中其他子控件转换为<code>View</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删掉了一些不关心的代码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rInflateChildren</span><span class="params">(XmlPullParser parser, View parent, AttributeSet attrs,</span><br><span class="line">        <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span><br><span class="line">        AttributeSet attrs, <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 createViewFromTag()</span></span><br><span class="line">            <span class="keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            <span class="comment">// 调用rInflateChildren()</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 将生成的View添加父控件中</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清楚的看到，由<code>rInflateChildren</code>开始，形成了一个循环：<code>rInflateChildren</code> -&gt; <code>rInflate</code> -&gt; <code>createViewFromTag</code> -&gt; <code>rInflateChildren</code>。通过循环遍历所有的子控件，直到整个布局文件结束  </p>
<p>此外，在最后可以看到，当<code>rInflate()</code>方法执行到最后时，会回调<code>parent.onFinishInflate()</code>方法，我们可以在重写这个回调方法获取View的属性</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正确地使用引导画面]]></title>
      <url>http://diov.github.io/2016/02/12/%5BT%5DSplash_Screens-the%20Right_Way/</url>
      <content type="html"><![CDATA[<p>原文：<a href="https://www.bignerdranch.com/blog/splash-screens-the-right-way/(" target="_blank" rel="external">Splash Screens the Right Way – bignerdranch.com</a></p>
<a id="more"></a>
<hr>
<p>启动界面只是用来浪费时间的，对吧？作为一个Android开发人员，当我看到一个引导界面时，我就知道有些可怜的码农又得在代码中添加一个3秒的延迟消息了。然后，在使用这个应用之前，我就只能跟个傻逼一样盯着画面3秒钟。而每次启动应用的时候，都必须经受这种折磨！</p>
<h1 id="What-Google-Recommends"><a href="#What-Google-Recommends" class="headerlink" title="What Google Recommends"></a>What Google Recommends</h1><p>当发现Google在<a href="https://www.google.com/design/spec/patterns/launch-screens.html" target="_blank" rel="external">material design规范</a>中建议你使用引导界面时，你可能会感到有些惊讶。<br>因为在此之前，Google曾经建议开发者不要使用引导界面，甚至称其为<a href="https://youtu.be/pEGWcMTxs3I?t=1434" target="_blank" rel="external">anti-pattern</a>。<br><img src="https://www.bignerdranch.com/img/blog/2015/08/adia_no_splash.png" alt="Anti-pattern"><br>那么这中间究竟发生了什么呢？</p>
<h1 id="Splash-Screens-the-Right-Way"><a href="#Splash-Screens-the-Right-Way" class="headerlink" title="Splash Screens the Right Way"></a>Splash Screens the Right Way</h1><p>我相信Google并没有打自己的脸，之前的建议与最新的建议并不矛盾。（但是仅仅为了添加引导界面而去浪费用户的时间并不是一个好主意。请不要这么做！）<br>一个Android应用在启动的时候总会花上一点时间，尤其是在冷启动（code start）时，通常这段时间总是无可避免的。那么，与其留下一个空白的屏幕，何不给用户展示一些有趣的东西呢？这应该就是Google建议的方式吧：当用户第一次启动应用的时候，不要浪费他们的时间，当然也不要展示一个空白的页面。<br>你可以在Google app最近的几次更新中观察到他们是如何正确地使用引导界面的，比如YouTube客户端：<br><img src="https://www.bignerdranch.com/img/blog/2015/08/youtube_splash.gif" alt="YouTube app"><br>当应用冷启动时（通常意味着这是启动应用最慢的情况），他展示引导界面的时间正好就是应用做一些初始化配置的时间。而如果一个应用已经被缓存了（后台进程），引导界面可能只会一闪而过。  </p>
<h1 id="Implementing-a-Splash-Screen"><a href="#Implementing-a-Splash-Screen" class="headerlink" title="Implementing a Splash Screen"></a>Implementing a Splash Screen</h1><p>如果我们使用布局文件给Activity添加内容，就需要消耗将布局文件转换为View的时间。所以我们需要将Activity的主题中的背景作为引导界面的内容来展示。首先在 <code>res/dralable</code> 中创建一个XML文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">layer-list</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">        <span class="attribute">android:drawable</span>=<span class="value">"@color/gray"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bitmap</span></span><br><span class="line">            <span class="attribute">android:gravity</span>=<span class="value">"center"</span></span><br><span class="line">            <span class="attribute">android:src</span>=<span class="value">"@mipmap/ic_launcher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在XML文件中，定义了背景颜色以及一个位图。<br>之后，需要将这些布局设置为引导界面的主题中的背景。在<code>styles.xml</code>中为引导界面添加主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"SplashTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.NoActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">android</span><span class="pseudo">:windowBackground"</span>&gt;<span class="at_rule">@<span class="keyword">drawable/background_splash&lt;/item&gt;</span></span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>SplashTheme</code>中，将drawable中的XML文件设置为页面背景的属性。再在<code>AndroidManifest.xml</code>中为Activity添加主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".SplashActivity"</span></span><br><span class="line">    <span class="attribute">android:theme</span>=<span class="value">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，在<code>SplashActvity</code>中，应该添加跳转到主界面的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：引导界面的内容是由主题中的属性决定的，而不是将View添加到引导界面中的。<br>如果你为给Activity准备了一个布局文件，那么Activity中的内容只会在应用初始化完成之后才可见，那时候通常都太迟了。我们要做的是应用初始化之前，在尽可能短的时间内将引导界面的内容展示出来。</p>
<h1 id="Doing-it-Right"><a href="#Doing-it-Right" class="headerlink" title="Doing it Right"></a>Doing it Right</h1><p>经过上面的步骤，我们就实现了一个引导界面：<br><img src="https://www.bignerdranch.com/img/blog/2015/08/sample_splash.gif" alt="right way splash view">  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[KillPay开发（AccessibleService）]]></title>
      <url>http://diov.github.io/2016/01/28/KillPay_Dev_Experience/</url>
      <content type="html"><![CDATA[<p>之前用<a href="http://coolapk.com/apk/com.oasisfeng.greenify" target="_blank" rel="external">绿色守护</a>的时候有一个功能，强制关闭后台进程。如果没有root的话，其实就时调用应用的详情页，然后强制停止。<br>刷完机以后并不打算安装支付宝（愈来愈流氓了），没几天就发现已经少不了这玩意儿了..</p>
<a id="more"></a>
<p>正好这段时间，有好多人自己开发抢红包的小应用，用到的就是AccessibleService。正好可以用来实现我的功能需求。先来分析一下业务，其实非常的简单：</p>
<ol>
<li>将AccessibleService开启</li>
<li>如果后台有进程在运行，跳转到应用详情界面</li>
<li>通过AccessibleService将进程停止</li>
</ol>
<p>用到的都是SDK中提供的API，如果有不明白的可以查阅文档，很详细。</p>
<h1 id="界面跳转"><a href="#界面跳转" class="headerlink" title="界面跳转"></a>界面跳转</h1><p>整个应用涉及到两个跳转，一个是”无障碍”（或者叫“辅助”）界面的跳转，另一个是指定应用的应用详情界面的跳转。<br>先来实现跳转无障碍界面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent accessibleIntent = <span class="keyword">new</span> Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);</span><br><span class="line">startActivity(accessibleIntent);</span><br></pre></td></tr></table></figure></p>
<p>接着是跳转到应用详情界面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent i = <span class="keyword">new</span> Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">i.setData(Uri.parse(<span class="string">"package:"</span> + packageName));</span><br><span class="line">startActivity(i);</span><br></pre></td></tr></table></figure></p>
<p>这里需要通过<code>setData(Uri data)</code>方法传入一个Uri，确定跳转到那个应用的详情界面。</p>
<h1 id="自动关闭"><a href="#自动关闭" class="headerlink" title="自动关闭"></a>自动关闭</h1><p>跳转到详情界面以后就是实现功能的关键步骤，通过AccessibleService自动关闭后台进程。首先来看一下AccessibleService的官方描述：</p>
<blockquote>
<p>An accessibility service is an application that provides user interface enhancements to assist users with disabilities, or who may temporarily be unable to fully interact with a device. For example, users who are driving, taking care of a young child or attending a very loud party might need additional or alternative interface feedback.</p>
</blockquote>
<p>也就是说AccessibleService是为不方便使用手机的人准备的，那我们正好不方便去点击”强制停止”-&gt;“确认”按钮（懒），所以完全可以借助这个API来实现自动的点击。</p>
<p>下面正式来使用AccessibleService：</p>
<ol>
<li><p><strong>在清单文件中注册</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".util.ForcecloseAccessibilityService"</span></span><br><span class="line">    <span class="attribute">android:label</span>=<span class="value">"@string/accessibility_service_label"</span></span><br><span class="line">    <span class="attribute">android:permission</span>=<span class="value">"android.permission.BIND_ACCESSIBILITY_SERVICE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.accessibilityservice.AccessibilityService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"android.accessibilityservice"</span></span><br><span class="line">        <span class="attribute">android:resource</span>=<span class="value">"@xml/accessibility_service_config"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想要使用AccessibleService必须要获取到<code>android.permission.BIND_ACCESSIBILITY_SERVICE</code>这个权限，<code>intent-filter</code>中的内容按照官方文档来填写就行了。至于<code>name</code>和<code>label</code>标签就不解释了。而<code>meta-data</code>中配置了服务的一些属性，我们在下一步完成</p>
</li>
<li><p><strong>配置AccessibleService</strong></p>
<p>在xml文件夹下创建一个.xml文件，文件名与<code>meta-data</code>中的<code>resource</code>保持一致就可以了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">accessibility-service</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:accessibilityEventTypes</span>=<span class="value">"typeAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFeedbackType</span>=<span class="value">"feedbackAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFlags</span>=<span class="value">"flagDefault"</span></span><br><span class="line">    <span class="attribute">android:canRetrieveWindowContent</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:description</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:notificationTimeout</span>=<span class="value">"100"</span></span><br><span class="line">    <span class="attribute">android:packageNames</span>=<span class="value">"com.android.settings"</span></span><br><span class="line">    /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>android:accessibilityEventTypes</code>：接受事件的类型</li>
<li><code>android:accessibilityFeedbackType</code>：对事件反馈的类型</li>
<li><code>android:canRetrieveWindowContent</code>：服务能否获取页面内容</li>
<li><code>android:packageNames</code>：想要监听那个包下的内容。注意，当我们使用AccessibleService来获取页面上的内容时，他是遍历所有的控件。如果不这是指定的报名的话，开启服务后会消耗大量的资源，所以建议如果只需要监听特定界面的话直接指定包名。</li>
</ul>
</li>
<li><p><strong>创建AccessibleService的子类</strong></p>
<p>创建AccessibleService的子类，需要实现<code>onAccessibilityEvent(AccessibilityEvent event)</code>和<code>`onInterrupt()</code>方法。其中我们对于自动关闭的业务逻辑就写在<code>onAccessibilityEvent(AccessibilityEvent event)</code>方法中，当服务接收到AccessibilityEvent时会回调这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndPerformAction</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找当前窗口中包含文字的按钮</span></span><br><span class="line">    <span class="keyword">if</span> (getRootInActiveWindow() == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//通过文字找到当前的节点</span></span><br><span class="line">    List&lt;AccessibilityNodeInfo&gt; nodes = getRootInActiveWindow().findAccessibilityNodeInfosByText(text);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">        AccessibilityNodeInfo node = nodes.get(i);</span><br><span class="line">        <span class="comment">// 执行按钮点击行为</span></span><br><span class="line">        <span class="keyword">if</span> (node.getClassName().equals(<span class="string">"android.widget.Button"</span>) &amp;&amp; node.isEnabled()) &#123;</span><br><span class="line">            node.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自定义的AccessibleService中，主要的方法就是自定义的<code>findAndPerformAction()</code>方法。<br>窗口内所有的控件及相关的内容都被封装在了<code>AccessibilityNodeInfo</code>对象中，根布局的<code>AccessibilityNodeInfo</code>下每一个控件仍然是一个个<code>AccessibilityNodeInfo</code>对象（与<code>jsonObject</code>的结构相似）。</p>
<ul>
<li>首先是通过<code>getRootInActiveWindow()</code>获取根布局，该方法在API 16才添加。API 16之前的可以使用<code>getResources()</code>方法；</li>
<li>之后调用<code>findAccessibilityNodeInfoByText(String text)</code>方法遍历所有的子控件，根据指定的字符串找到控件的集合；</li>
<li>因为我们已经知道在应用详情的界面，通常一个指定的字符串只会出现在一个控件上。所以直接获取集合的第一个元素，调用<code>performAction(int action)</code>，传入<code>AccessibilityNodeInfo.ACTION_CLICK</code>，完成点击事件。</li>
</ul>
<p>之后，在<code>onAccessibilityEvent(AccessibilityEvent event)</code>方法中，我们只需要依次调用<code>findAndPerformAction(&quot;强行停止&quot;)</code>和<code>findAndPerformAction(&quot;确定&quot;)</code>就可以实现自动停止进程的功能了。</p>
</li>
</ol>
<h1 id="一些重构"><a href="#一些重构" class="headerlink" title="一些重构"></a>一些重构</h1><p>写完之后发现在<code>MainActivity.java</code>中加入了不少 <em>迷之嵌套</em> ，就简单的重构了一下。<br>其实在实际开发中对于业务逻辑不注意的话很容易就添加很多嵌套，增大了代码阅读的难度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isInstall) &#123;</span><br><span class="line">    Snackbar.make(view, <span class="string">"应用未安装"</span>, Snackbar.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">    Snackbar.make(view, <span class="string">"后台未运行,无需关闭"</span>, Snackbar.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (AppHelper.isServiceRunning(MainActivity.<span class="keyword">this</span>, getPackageName())) &#123;</span><br><span class="line">    <span class="comment">// 根据包名跳转系统自带的应用程序信息界面,并自动关闭</span></span><br><span class="line">    jumpDetailInfo(packageName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Snackbar.make(view, <span class="string">"服务未开启,请打开"</span>, Snackbar.LENGTH_SHORT).setAction(<span class="string">"打开"</span>,</span><br><span class="line">            <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    openAccessibleSetting();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是重构后的代码，感觉仍然写的不够优雅…</p>
<p>至此，这个应用的主要功能就都完成了。因为都是直接调用SDK中的API，所以并没有什么难点。其他的一些查询应用安装及后台是否运行的方法也很简单，就不一一介绍了。有兴趣的可以查看我的仓库 <a href="https://github.com/diov/KillAPay" target="_blank" rel="external">diov/KillAPay</a></p>
<h3 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h3><p>十月份时候百度全家桶爆出的漏洞（后台），和最近了解到的支付宝各种强制开启“生活圈”和后台下载小视频，以及支付宝iOS端的后台播放无声音乐（多老的招数了）。似乎BAT里面反倒是山寨帝国Tencent显得最良心了。<br>不可否认BAT在国内互联网行业中的技术领军地位，也很佩服淘宝这样的应用要应对500多个业务还能很好实现（虽然很丑陋）的强大。但是真的想不明白这样完全不在乎用户感受的设计是出于什么样的一种考虑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 触摸事件分发源码]]></title>
      <url>http://diov.github.io/2016/01/17/Analisis_of_Touchevent_in_Android/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://trinea.github.io/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf" target="_blank" rel="external">Mastering    the    Android Touch    System</a></p>
<p>作为以触摸作为主要交互的系统，触摸事件是我们在写代码时无可避免的。不论是对触摸事件进行响应，还是拦截一些不需要关心的事件，都需要我们对View中触摸事件的分发机制进行了解。</p>
<a id="more"></a>
<h2 id="ViewGroup事件的分发拦截和处理"><a href="#ViewGroup事件的分发拦截和处理" class="headerlink" title="ViewGroup事件的分发拦截和处理"></a>ViewGroup事件的分发拦截和处理</h2><p>触摸事件一般是从Activity开始分发，但是这里我们就跳过Activity，直接从根布局也就是ViewGroup开始了。</p>
<h3 id="事件分发-dispatchTouchEvent"><a href="#事件分发-dispatchTouchEvent" class="headerlink" title="事件分发(dispatchTouchEvent)"></a>事件分发(dispatchTouchEvent)</h3><ul>
<li><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*...省略...*/</span></span><br><span class="line">        <span class="comment">// 1. 将ACTION_DOWN事件作为一系列触摸事件的起始，对事件进行初始化.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 在开始一系列新的手势时清除之前的所有状态（可能由于app切换、ANR所遗留下来）</span></span><br><span class="line">            <span class="comment">// 将mFirstTouchTarget重置为null(在clearTouchTargets()中)，并且回收事件</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();<span class="comment">// 重置所有的触摸状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 检测是否需要拦截.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当触摸事件为ACTION_DOWN或者mFirstTouchTarget不为null时（也就是已经找到接受事件并可以接受后续事件的子View）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)可以设置ViewGroup是否禁用拦截</span></span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                <span class="comment">// 如果没有禁用拦截，那么就调用当前ViewGroup的onInterceptTouchEvent()方法。对是否拦截进行判断</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果禁用拦截，那么直接返回false</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 触摸事件不是初始的ACTION_DOWN事件，并且没有接收后续事件的View控件。ViewGroup会继续拦截触摸事件</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果对事件进行了拦截，或者已经有一个控件对手势进行处理。那么进行normal的事件分发（这里不太明白）</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">// 判断事件是否是ACTION_CANCEL或者之前的手势遗留的</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;<span class="comment">// 判断VIewGroup是否可以分发事件</span></span><br><span class="line"></span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// 如果事件不是ACTION_CANCEL并且没有进行拦截</span></span><br><span class="line"></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus(): <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 3. 当事件为ACTION_DOWN时进入该方法（另两个条件不太明白）</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent</span><br><span class="line">                    .ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取触摸的位置</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                    <span class="comment">// 按照从前到后的顺序遍历子View，找到可以接收事件的子View</span></span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="comment">// 后添加的View覆盖在最上层，从集合的最后向前遍历</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>) ? children[childIndex] : preorderedList.get</span><br><span class="line">                                (childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*...省略...*/</span></span><br><span class="line">                        <span class="comment">// 如果子View不能接收事件，或者Transformed(不太明白)后的触摸点不在子View中，continue。加速查找</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child,</span><br><span class="line">                                <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果没有可以接收事件的子View就返回null，否则返回子View</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果已经找到了接收事件的子View，就跳出循环</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 通过dispatchTransformedTouchEvent()方法，递归遍历所有子View。</span></span><br><span class="line">                        <span class="comment">// 如果返回true，说明事件被子View消费了</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">//将接收并消费ACTION_DOWN事件的子View其赋值给newTouchTarget，作为后续事件的接受者。跳出循环</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有找到可以接收事件的子View，但是之前某个子View消费过触摸事件。那么将该子View赋值给newTouchTarget</span></span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 如果触摸事件不是ACTION_DOWN时，处理事件.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// a. 没有哪个子View能够消费ACTION_DOWN事件，或者后续的事件被拦截了</span></span><br><span class="line">            <span class="comment">// 将ViewGroup作为一般的View，调用dispatchTransformedTouchEvent()对事件进行处理(参数传入null)</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b. 存在某个子View能够消费ACTION_DOWN事件</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    <span class="comment">// 如果能消费ACTION_DOWN的子View，同时也在这次触摸事件中消费ACTION_DOWN事件，也就是第一次消费事件。(瞎猜的:P)</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;中</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对于ACTION_DOWN后续的事件，根据onInterceptTouchEvent()的返回值决定是否想子View发送ACTION_CANCEL</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child) || intercepted;</span><br><span class="line">                    <span class="comment">// 再将事件通过dispatchTransformedTouchEvent()交由子View处理</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*...省略...*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            <span class="comment">// 如果对后续的事件设置了CANCEL或者事件是ACTION_UP.重置事件状态</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<ol>
<li>将ACTION_DOWN事件作为一系列触摸事件的起始，对事件进行初始化.<br>这个步骤最重要的一点就是<strong>将mFirstTouchTarget置为null</strong></li>
<li>检测是否需要拦截<br>先判断当前ViewGroup是否禁用了拦截。如果禁用了，直接返回false<br>如果没有禁用，当触摸事件为ACTION_DOWN或着是接收后续事件时会调用<strong>onInterceptTouchEvent()</strong>进行判断</li>
<li>如果不进行拦截，当触摸事件为ACTION_DOWN时(触摸事件的起始)进行特殊的判断<br>递归遍历子View，找到能够消费事件的子View。在这个过程中多次调用dispatchTransformedTouchEvent()方法以递归的形式将事件依次发送给子View<br>这个步骤最重要的一点就是是否<strong>给mFirstTouchTarget赋值</strong></li>
<li>处理完ACTION_DOWN后，对事件是否消费做判断(根据<strong>mFirstTouchTarget是否为null</strong>)<br>如果没有子View可以消费事件或者事件被拦截，事件通过dispatchTransformedTouchEvent()由父ViewGroup处理，返回结果<br>如果当前事件为ACTION_DOWN并且被消费，返回true<br>如果当前事件为ACTION_DOWN的后续事件，根据onInterceptTouchEvent()的返回值决定向下分发的时ACTION_CANCEL还是当前事件。通过dispatchTransformedTouchEvent()由子View处理，返回结果</li>
</ol>
</blockquote>
<hr>
<h3 id="ViewGroup中事件的拦截"><a href="#ViewGroup中事件的拦截" class="headerlink" title="ViewGroup中事件的拦截"></a>ViewGroup中事件的拦截</h3><ul>
<li><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>ViewGroup中对事件是不进行拦截的，将其向下传送</p>
</blockquote>
<hr>
<h3 id="ViewGroup中事件的处理"><a href="#ViewGroup中事件的处理" class="headerlink" title="ViewGroup中事件的处理"></a>ViewGroup中事件的处理</h3><ul>
<li><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span><br><span class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">// 1. 根据传入的参数cancel或者事件决定发送的事件是否时ACTION_CANCEL</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="comment">// 2. 根据传入的参数child决定是将事件交由父ViewGroup还是交由子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; dcancelesiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>虽然这个方法很长，但是其实我们只需要关注两个参数：<code>boolean cancel</code>和<code>View child</code></p>
<ol>
<li>boolean cancel控制了发送的事件是否是ACTION_CANCEL</li>
<li>View child控制了事件是发送给子View还是交由父ViewGroup处理</li>
</ol>
<p>事件是否被消费决定了最后的返回值。</p>
</blockquote>
<ul>
<li>ViewGroup是View的子类，他并没有重写View的onTouchEvent()方法。所以如果事件交由父ViewGroup处理，实际调用的是<code>super.dispatchTouchEvent()</code></li>
</ul>
<hr>
<p>将触摸事件从ACTION_DOWN -&gt; ACTION_MOVE -&gt; ACTION_UP看做一系列触摸事件的整体。当ViewGroup处理这一系列事件的过程中，我们需要特别注意一个变量：mFirstTouchTarget。<br>在ACTION_DOWN事件中mFirstTouchTarget被置为了null。那么mFirstTouchTarget的最终值就意味着是否找到了能够消费触摸事件的子View。来看一下mFirstTouchTarget在那些情况下可以被赋值：</p>
<ol>
<li>在ACTION_DOWN事件中：a).父ViewGroup不对事件进行拦截；2).点击点位于某个子View上；3). 被点击的子View消费了ACTION_DOWN事件</li>
<li>在ACTION_DOWN的后续事件中：a). 首先必须存在可以消费ACTION_DOWN事件的子View，否则后续事件都无法向下分发；b). 在分发后续事件时，父ViewGroup不对事件进行拦截</li>
</ol>
<hr>
<h2 id="View中事件的分发和处理"><a href="#View中事件的分发和处理" class="headerlink" title="View中事件的分发和处理"></a>View中事件的分发和处理</h2><p>上面我们说到了当ViewGroup中所有的子View都无法消费触摸事件时，会把事件返回给ViewGroup，再调用View的<code>dispatchTouchEvent()</code>方法，那么就来看看具体的实现吧</p>
<h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><ul>
<li><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// NestedScroll是Lolipop之后添加的嵌套滚动机制，用于解决子View不处理滑动事件时，父View也无法处理的该事件的问题</span></span><br><span class="line">        <span class="comment">// 这里我们只要看作是触摸事件时清除掉之前的触摸事件的状态就可以了</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">// ListenerInfo是封装了一系列监听器的类</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            <span class="comment">// 1. 首先判断是否给View添加了onTouchListener监听器；mViewFlags是在View构造时传入的一系列状态值，这里用来判断View是否是enabled的。</span></span><br><span class="line">            <span class="comment">// 如果前面都为true，最后执行监听器的onTouch()方法，并根据其返回值决定result的值</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="comment">// 2. 当未设置onTouchListener或者onTouch()方法返回false（表示事件未被消费），则会调用onTouchEvent()方法并决定result的值</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...省略...*/</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>相比起ViewGroup，View的dispatchTouchEvent()方法就简单多了。重点主要有两点：</p>
<ol>
<li>判断View是否设置了onTouchListener，相信设置监听器的方法大家应该都知道了——setOnTouchListener()。如果设置了监听器，就调用监听器的<code>onTouch()</code>方法</li>
<li>如果没有设置监听器或者onTouch()返回false时，会调用<code>onTouchEvent()</code>方法</li>
</ol>
</blockquote>
<hr>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li><h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取点击的位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当触摸事件为ACTION_UP并且View未设定pressed属性时，设置pressed状态未false</span></span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 如果当前View同时具有clickable和disabled两个属性，返回true(消费事件但不作出响应)</span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将事件委托给一个代理进行处理，如果代理的onTouchEvent()返回true，表示事件被消费（不懂）</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                    <span class="comment">//做了一系列判断，设置按下状态并迅速弹起</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// 判断未tap（轻触）状态，移除长按的回调</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果View没有夺取焦点</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// 调用一个处理Click事件的Runnable对象进行异步的处理</span></span><br><span class="line">                            <span class="comment">// 最终调用了onClickListener的onClick()方法</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*...省略...*/</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="comment">// 处理长按事件等</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="comment">//移除回调、清除状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">/*...省略...*/</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 只要View是clickable、longclickable或者contextclickable的，不论触摸事件是什么都消费事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PerformClick类中执行的还是performClick()方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformClick</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        performClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理Click事件的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        <span class="comment">// 调用onClickListener的onClick()方法</span></span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h4></li>
</ul>
<blockquote>
<p>对onTouchEvent()的分析，我们主要关注其返回值</p>
<ol>
<li>View同时具有clickable和disabled两个属性，返回true(消费事件但不作出响应)</li>
<li>只要View是clickable、longclickable或者contextclickable的，不论触摸事件是什么都消费事件</li>
<li>如果不是上面的情况，返回false</li>
</ol>
<p>要注意的是，在第二种情况下，当触摸事件是ACTION_DOWN时，创建了一个处理Click事件的Runnable对象并将其加入消息队列<br>这个Runnable对象内部执行的是performClick()方法。而我们可以看到，如果Runnable对象添加到消息队列失败的话时会直接调用这个方法的<br>在performClick()中，判断了是否设置了onClickListener，最终调用了onClickListener的onClick()方法</p>
</blockquote>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git基础命令]]></title>
      <url>http://diov.github.io/2016/01/10/Git_basic_command/</url>
      <content type="html"><![CDATA[<h1 id="Git-Try-笔记"><a href="#Git-Try-笔记" class="headerlink" title="Git Try 笔记"></a>Git Try 笔记</h1><p>Code School上<a href="https://try.github.io/" target="_blank" rel="external">Git Try</a>的学习笔记。</p>
<p>之前直接在Android Studio上使用git插件的时候，因为不了解git的命令和运作，搞出了不少岔子。最惨的时直接删了两个repository…</p>
<p>用上Linux Mint后慢慢的对Command Line熟悉起来，想着把git再好好研究一下。本文的名称大多沿用<a href="http://www.ruanyifeng.com/blog" target="_blank" rel="external">阮一峰博客</a>的命名</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a><a id="more"></a> </h2><ul>
<li>初始化一个<code>Git</code>代码库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init&#10;&#10;Initialized empty Git repository in /.git/&#10;&#10;Success!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仓库(Repository)就是Git初始化后，用来进行版本控制的文件夹</p>
</blockquote>
<hr>
<ul>
<li>获取本地<code>Git</code>代码库的状态</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git statu&#10;&#10;# On branch master&#10;#&#10;# Initial commit&#10;#&#10;nothing to commit (create/copy files and use &#34;git add&#34; to track)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显示Git分支、提交的内容</p>
<p>当仓库中的文件发生改变时，通常会有以下状态</p>
<ol>
<li>untracked：尚未被Git检索的状态</li>
<li>staged：准备被Git提交(<code>commit</code>)，可以理解为暂存在本地仓库</li>
<li>unstaged：不会被Git提交</li>
<li>deleted：文件在本地被删除，等待在Git上删除</li>
</ol>
<hr>
</blockquote>
<ul>
<li>将文件添加到本地<code>Git</code>缓存区中</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add xxx.txt&#10;$ git add &#8216;*.txt&#8217;&#10;$ git add -A&#10;&#10;Nice job, you&#39;ve added xxx.txt to the Staging Area</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过add命令将文件保存到临时区域()。支持通配符及全部上传</p>
<p>Staging Area:缓存区，在我们通过<code>commit</code>将文件提交到<code>Git</code>上之前临时保存</p>
</blockquote>
<hr>
<ul>
<li>将缓存区的文件提交到<code>Git</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#8216;xxx&#8217;&#10;&#10;[master (root-commit) 2e8cda3] Add cute octocat&#10; 1 file changed, 1 insertion(+)&#10; create mode 100644 octocat.txt&#10;&#10;Success!</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>commit</code>:是仓库状态的一个存档，通过<code>commit</code>可以查看提交的所有log<br><code>-m ‘xxx&#39;</code>：每次提交的备注</p>
</blockquote>
<hr>
<ul>
<li>查看提交记录</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log&#10;$ git log --summary</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过<code>--summary</code>查看详细的记录(包括提交作者、时间、备注及每个更改的文件信息)</p>
</blockquote>
<hr>
<ul>
<li>增加一个远程<code>Git</code>仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/try-git/try_git.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个远程仓库，地址为github上提供的地址。并且将该远程仓库命名为origin</p>
</blockquote>
<hr>
<ul>
<li>将本地仓库推送到远程仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>origin是远程仓库的命名，分支默认是master<br><code>-u</code>表示Git会记住Git状态，下次只需要通过<code>git push</code>就可以进行推送</p>
</blockquote>
<hr>
<ul>
<li>从远程<code>Git</code>仓库同步</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将远程仓库同步代码，与本地合并<br><code>git stash</code>：当同步文件时，可能不想将本地的更改覆盖。可以通过stash命令将本地的更改隐藏<br>在同步完成后，再调用<code>git stash apply</code>将本地更改应用到仓库</p>
</blockquote>
<hr>
<ul>
<li>比较缓存区与仓库的代码差异</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HEAD：HEAD是记录不同<code>commit</code>位置的标示，默认的HEAD是最近一次提交的<code>commit</code><br>所以通过HEAD可以快速地确定所在版本，而不需要对比SHA值<br>通过<code>diff</code>命令，可以显示文件之间的冲突</p>
</blockquote>
<hr>
<ul>
<li>重置缓存区的文件</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset xxx.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将缓存区的文件重置到上一次<code>commit</code></p>
</blockquote>
<hr>
<ul>
<li>将缓存区的文件恢复到工作区</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- xxx.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>reset</code>命令重置后，缓存区的文件仍然存在。通过<code>checkout</code>命令将其恢复到工作区</p>
</blockquote>
<hr>
<ul>
<li>创建本地分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>branch</code>命令可以在版本控制中创建一个分支。<br>分支是并发开发的基础，在分支上开发后可以再合并到主分支上。</p>
</blockquote>
<hr>
<ul>
<li>查看分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch&#10;&#10; clean_up&#27;&#10;* &#27;master&#27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>branch</code>命令可以查看本地的分支及当前所在的分支</p>
</blockquote>
<hr>
<ul>
<li>切换分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &#60;branch&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 可以通过git checkout -b <branch>命令同时实现创建+切换分支的操作</branch></p>
</blockquote>
<hr>
<ul>
<li>清空所有仓库</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &#39;*.txt&#39;&#10;$ git rm -r &#60;fold_name&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的命令与Linux命令行相同，支持通配符和递归删除文件夹<br>如果没有通过命令行，直接删除文件的话，还是需要把删除的文件通过<code>git rm</code>命令在<code>Git</code>中删除的。<br>可以在<code>git commit</code>命令中使用<code>-a</code>来自动移除已被删除的文件。例如：`git commit -am <message>‘</message></p>
</blockquote>
<hr>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master&#10;$ git merge clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并分支首选需要切换会朱分支，再通过<code>merge</code>命令合并分支</p>
</blockquote>
<hr>
<ul>
<li>删除分支</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d clean_up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>branch</code>命令后加入<code>-d</code>表明删除(delete)<br>如果尚未合并，<code>-d</code>命令不会起作用。可以添加<code>-d-f</code>强制删除(force)，或者<code>-D</code></p>
</blockquote>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>http://diov.github.io/2016/01/01/hello/</url>
      <content type="html"><![CDATA[<p>Hello Github!</p>
]]></content>
    </entry>
    
  
  
</search>
